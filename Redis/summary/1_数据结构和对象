1.SDS(Simple Dynamic String)

-------------------------------------------------------------
  在Redis中，C字符串用于string literal ---> 不需要修改字符串
  SDS为动态字符数组     ----> 类似动态数组vector
  动态含义:数组大小可变 ----> 内存空间可变
  实现方式:在添加新的数据时，原始空间可能不够，于是开辟新的空间，将原来的数据拷贝到新空间
  空间扩容策略:若每次扩容都只满足可以容纳新的数据，那么会导致空间地频繁扩容
               空间扩容涉及到原空间释放，新空间申请，数据拷贝 ---> 开销比较大 ---> 应尽量避免频繁的操作
               所以扩容时会申请较多的空间，满足新数据的空间要求后，剩下的空间则为预留空间
               下次添加数据时，则会先使用预留空间，而不会进行空间扩容 ---> 以此来减少空间扩容的次数
  
  Redis的扩容策略:SDS长度<1MB时(小空间)，倍增扩容    ---> 减少扩容次数       
                  SDS长度>1MB后(大空间)，线性扩容    ---> 减少内存浪费
-------------------------------------------------------------

  struct sdshdr{
    char buf[];   //字节数组.数据末尾为'\0' ---> 兼容C库函数
    int len;      //数组中已经使用的字节数
    int free;     //数组中未使用的字节数 ---> 预留空间
  }

  SDS的优点:
  1)快速获取字符串长度        --->   通过len属性获得
    传统C字符串则需要遍历统计 --->   O(n)
  
  2)避免内存溢出
    考虑函数: strcat(char* dest,const char* src);
    其假设dest的内存空间足够大，可以容纳src
    若用户在执行函数时没有为dest分配足够的空间，则拼接后的字符串的内存会溢出到其他数据的内存中
    比如:s1和s2内存相邻
    strcat(s1,"hello") --->  hello溢出到s2的内存中

    SDS提供函数:sdscat(sds dest,const char* src)
    在拼接前，其会先检查dest空间是否足够，若不够则先对sds dest进行扩容

  3)惰性空间释放
    SDS提供函数:sdstrim(sds s,const char* pattern) --> 用于字符串的裁剪 
    被裁减的字符串的空间并没有被立马释放，而是通过free属性将其标记为可用 ---> 原数据已没有用，可被新数据覆盖

-------------------------------------------------------------
  4)二进制安全
    C字符串中的字符必须符合某种编码(比如ASCII)
    而字符串中不能出现空字符，否则程序会将前面出现的空字符误认为字符串结尾
    这些限制使得C字符串只能保存文本数据，不能保存图片，音频这样的二进制数据

    而SDS存储字节数组:char[]    ----> 一系列的二进制数据
    其不会对数据做任何限制，假设 ---> 数据写入时是什么样的，被读取时就是什么样的
-------------------------------------------------------------




-------------------------------------------------------------
4.整数集合
  struct intset{

    //stored data
    int8_t contents[];

    //meta-data
    uint32_t encoding;   //编码方式
    uint32_t length;     //元素数量
  }
 contents中存储着整数集合:整数从小到大排序(维护有序性需要不停地对数据进行移动) 且 不会重复
 其实contents就是一片内存空间.
 用encoding来解释这片内存空间存储的数据类型
 比如:
 encoding为INTSET_ENC_INT16,contents中就存储16位的整数
 所以操作函数需要先判断encoding,再将数组转为对应的类型
 比如:INTSET_ENC_INT16          (int16_t*)(contents)

 对于上层使用者而言，其只关心数据的顺序，不关心数据的内存分布
 所以在查找时，上层其提供数据顺序编号，比如第5个数据。
 下层则会先根据encoding，将数组转为相应的类型，再根据编号查找到对应的内存，取出内存中的数据
 比如: memcpy(&v64,((int64_t*)contents)+idx,sizeof(v64)); --> 将取出的数据存放到v64中

 假如contents存储着16位数据，若此时需要添加数据100000 ---> 长度超过16位 ----> 32位数据
 为了让数组中的元素类型保持一致  
 应首先将数组的元素进行类型升级
 例子:
 原数据:16位.现要插入100000 --> 32位
  0~15  16~31  32~47
   1     2      3
 升级步骤:
 1)扩展底层空间大小   ----> 调用realloc() ---> 在尾后追加内存，保证空间连续.或者尾后内存不足，重新分配一个更大的空间，并进行数据拷贝
   扩展后内存情况为:
   0~15  16~31  32~47    47~128
    1     3      4      扩展空间
 
 2)将数据转为新类型 ---> 数据的类型通过其占有内存大小来体现 
   将数据放到新的内存位置上,并维持有序性
   比如:
   3在原始数据中排行第二 ---> 在32位新空间的位置为: 1*32 ~ 2*32-1
   所以有
   0~31  32~63  64~95    96~128
    1     3      4      (100000)

 3)插入新数据
   因为只有当新数据的位数超过了当前数据的位数时(新数据肯定比当前所有数据都大)，才会进行类型升级
   所以新数据肯定插在末尾
-------------------------------------------------------------
   

-------------------------------------------------------------
5.压缩列表
  特点:在连续的内存区域上存储(整数，字符串)集合
  内存的分布情况为:
  zlbytes  zltail  zllen  entry1  entry2....  zlend
  zlbytes,zltail ,zllen ,zlend是这片内存的meta-data
  zlbytes:
    4字节，占用的字节数
  zltail:
    4字节，最后一个entry距离压缩列表起始地址的偏移量    ---> 无须遍历就可以快速定位表尾节点
  zlen:
    2字节，记录节点数量    ----> 无须遍历就可以获得节点数量
  zlend:
    1字节，标记列表的末端  ----> 遍历的终点
--这些meta-data的大小固定  ----> 位置固定  ----> 不需要额外的变量来定位

--entry可以存储整数或者字符串 
  那么就需要meta-data来标识entry的类型

typedef struct zlentry {
    // 指向当前节点的指针
    unsigned char *p;


    unsigned int  prevrawlen;             //前置节点的长度:通过p-prevrawlen就可以定位到前一个节点 --> 实现类似双向链表的效果
    unsigned int  prevrawlensize;         //前置节点的长度不定 ----> 实际的prevrawlen的长度也就不定
                                          //Redis采取的策略: 若前置节点长度 < 254，那么prevrawlen就用1个字节来记录
                                                                        若  > 254，那么prevrawlen就用5个字节来记录
                                                                                   第一个字节设为254 --> 标识
                                                                                   后面的4个字节真正地记录长度
                                          //prevrawlensize就用来记录prevrawlen的实际长度


    unsigned int len;                     //当前entry的总长度:通过p+len就可以定位到下一个节点
    unsigned int lensize;                 //记录len实际占用的内存长度

    // 等于 prevrawlensize + lensize
    unsigned int headersize;             //header大小 --> header包括prevrawlen和len两部分 ---> 所以大小就为lensize+prevrawlensize

    unsigned char encoding;         //数据的编码类型:整数？字符串？每个entry的长度？
                                    //比如编码为 00001011，表明entry存储字节数组,长度为11  ---> 字符串,比如:hello wrold
                                    //比如编码为 11000000，表明entry存储int16_t的整数值


} zlentry;
  一个entry的内存分布
  |prevlen   encoding  content|:可以通过解析出这三个属性，就可以构建出一个zlentry --> 内存结构
--prvlen解析:若第一个字节的值为254，则prevlen含有5个字节  -------------------------------------------------
  encoding解析:若以11开头，则content为整数，encoding只占一个字节
               若以00开头，则content保存长度 <64的字节数组.encoding只占一个字节
               若以01开头，则content保存长度 <16384的字节数组，encoding占三个字节
               若以10开头，则encoding占有5个字节，content保存<......的字节数组
  解析出encoding以后，就知道content的起始和长度了

  将元素插入指定节点p前面:
  1)先遍历找到该节点p
    解析p节点的内存,构建出该节点的zlentry

  2)构建出新插入元素节点的内存大小:size
    prevlensize,endconding size,元素size 

-------------------------------------------------------------
  3)用size更新p节点的prelen
    之前p节点的prelen可能为一个字节
    而size长度>254 ---> 新的prelen就需要5个字节 ---> p节点的大小也会扩张4个字节 ---> p的下一个节点的prevlen也需要更新 --> 可能会出现同样的情况 ---> 连锁更新
  
  4)计算prelen(连锁)更新后，压缩列表的新长度,对压缩列表进行内存调整 ---> realloc()

  5)将p节点以及后面的节点进行内存移动，为新节点腾出空间  ---> memmove()
-------------------------------------------------------------
  5)在内存中填入新节点
    prevlen encoding content

  可见压缩列表对内存的使用效率非常高 ----> 并没有使用固定的数据类型，而是根据实际数据确定数据占用的内存大小
                                           若使用固定的数据类型，则会将值设置的很大，比如int64_t，以兼容各种情况
                                           但这种兼容也就会造成内存浪费
                                           比如在int64_t类型空间上可能就只使用了一个字节
                                           因为没有设定固定的数据类型，所以需要自行制定规则来解释这片内存
                                           参考prevlen,encoding的规则
-------------------------------------------------------------


  
6.对象
  Redis数据库存储KV键值对
  K和V的类型统一为redisObject
  用对象表示存储的各种类型的数据:字符串，列表，hash对象，集合对象，有序集合对象
  那么redisObject中肯定需要meta-data来标识自己存储的是哪一种对象  -----------------------
  strcut redisObject{
    //stored data
    void* ptr;              //实际的数据

    //meta-data
    unsigned type:4;        //对象类型
    unsigned encoding:4;    //该对象类型的底层数据结构实现类型
    ...对象的其他属性
  }
  
-------------------------------------------------------------
  Redis中含有五种对象,每种对象都有多种底层数据结构来实现
  每种数据结构都有自己的最佳适用数据范围.
  当对象中存储的数据不适用于当前数据结构实现时，就可以切换实现方式，以到达在不同场景下均能高效率地存储数据的目的
-------------------------------------------------------------

  1)REDIS_STRING
    三种实现方式
    a.INT
      适用于 在字符串对象中存储单个整数，且整数能用long来表示 

    b.RAW
      适用于 存储长字符串(>39字节)
      底层数据结构为:SDS
      创建一个该类型的对象时，会进行两次内存
      第一次:为redisObject分配内存
      第二次:为SDS分配内存
      为什么要分两次?
      因为SDS中存储长字符串 ---> 内存较大
      如果只进行一次分配，则需要很大的连续内存空间 ---> 不一定能找到

    b.EMBSTR
      适用于 存储短字符串 以及 长度较长的整数，long double类型的浮点数 ---> 存储时会转为字符串类型，读取时再转为数字类型
      它的底层也SDS.
      但由于它存储短字符串
      所以可以为SDS和redisObject一起分配内存   ----> 释放时也只需要一次free即可
      而且在缓存中redisObject和SDS也是可以在一起的 ---> 能更好地利用缓存优势 
      RAW的实现就没有利用缓存的优势，因为还是需要到内存中读取SDS

    三种实现方式的切换

    1.INT ---> RAW
      对字符串对象执行APPEND命令   
      由于只能对字符串进行APPEND 
      所以需要INT到RAW的转换
    2.EMBSTR --> RAW
      EMBSTR并没有写操作接口  ---> 只读字符串
      所以对字符串对象进行修改时，需要从EMBSTR转为RAW
      
  2)REDIS_LIST
    有两种实现方式
    a.ZIPLIST
-------------------------------------------------------------
      当保存的元素(字符串或者整数)较小(小于64字节)且数量较少(小于512)时才使用 
      压缩列表是在一片连续的内存空间上存储数据 
      若元素过大和过多，则导致realloc()频繁地重新申请内存+数据拷贝
-------------------------------------------------------------
    b.LINKEDLIST
  
  3)REDIS_HASH
    存储键值对
    有两种实现方式
    a.ZIPLIST
      K和V紧挨在一起
      同样只适用于元素较小且数量较少的情况
    b.HT
      用dict存储KV
  
  4)REDIS_SET 
    集合去重
    两种实现
    a.INTSET
      整数集合
      只适用于整数集合且集合中数量较少 --> 和压缩列表一样，其是在一片连续的内存上存储整数
    b.HT
      V全部设为NULL

  5)REDIS_ZSET
    有序集合:每个元素都对应一个可以用于排序的score  ---> 集合元素结构为 <redisObject,socre>
    两种实现
    a.ZIPLIST
      data和score紧挨在一起
      插入时，维护有序性 ---> 根据score寻找插入位置

    b.SKPLIST
      底层数据结构为:
      struct zset{
        zskiplist* zsl;
        dict* dict;
      }
-------------------------------------------------------------
      包含了一个跳表和字典
      字典结构缺点:不适合进行范围性查找   ---> 而跳表则正好可以弥补这一缺点
      让跳表和字典通过指针共享集合元素    ---> 不会有多余的内存浪费
-------------------------------------------------------------


7.每种对象都有专属的操作命令(SET只适用于字符串对象)
  所有对象之间也共享一些命令(比如DEL)
  client向server发送命令，请求操作指定的对象(redisObject)
  server会检查对象的type是否相兼容  ---> 查表???
  然后根据对象encoding调用相应的数据结构操作接口

8.对象的内存回收
  在redisObject中含有引用计数器 refcount.
  并提供了操作引用计数器的接口
  创建对象时，refcount =1;
  当该对象被使用时，++refcount
        使用完毕后，--refcount
  若refcount = 0，则释放对象内存
  比如
  当判断键过期时，就--refcount
  难点在于:如何把控对象的生命周期? ---> 何时调用incr和decr?
  最简单的例子
  {
    创建对象
    操作对象
    --refcount ---> 释放对象
  }
  但若在其中嵌套函数呢
  {
    创建对象obj
    ++refcount;
    操作1 func(obj)   //要保证在嵌套函数中，该对象不会被释放.所以会提前++refcount
                      //或者在func中先执行++refcount
    操作2 
    --refcount;
  }

-------------------------------------------------------------
9.对象共享
  对象的引用计数机制使得某个对象可被其他多个对象共享
  比如数据A被对象B持有
  现有数据C,也需要对象A的数据
  正常情况下需要将B.A深拷贝到对象C中,每个对象含有独立的数据副本，对象掌控着数据副本的生命周期 ---> 对象被销毁会导致数据副本也被销毁 
  若执行浅拷贝，那么多个对象共享数据C，那么最后谁负责来释放C呢？ ---> 对象的引用计数可以克服这一缺点
  每一次浅拷贝都会使得共享数据的引用计数器+1
  当对象被销毁前，其先会递减共享数据的引用计数.若减至0，则销毁共享数据
-------------------------------------------------------------

  redis服务器在启动前会创建数值为0~9999的字符串对象
  当服务器需要使用时(比如SET A 100)，其不会真的创建100这个字符串对象，而是共享之前创建好的(++refcount)

  Redis只支持共享字符串对象
  因为使用共享对象前，需要判断 目标对象 和 某个共享对象是否匹配  ---> 若对象过于复杂，则匹配的复杂度就越高

-------------------------------------------------------------
10.对象的时效性
   redisObject含有属性lru : 记录最后一次该对象被访问的时间点
   当前时间 - obj.lru 就是对象闲置时间
   当服务器内存吃紧时，就需要释放一些内存 ----> 释放哪些呢? ---> 优先级低且闲置较长的数据
-------------------------------------------------------------

