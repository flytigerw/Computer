1.Redis server为事件驱动程序
  事件:
  文件事件:
    server与client通过socket进行通信
    使用基于epoll的reactor模型 
     1)注册fd
       <fd,handler>
     2)监听fd
       epoll_wait()
     3)监听某fd已经就绪后，根据到来的事件类型，调用handler中相应的处理函数
       Redis将多个有序的放入到队列中，单线程逐个处理
       
  时间事件:
    包括周期事件和定时事件
    Redis使用链表为维护多个定时器
    在Reactor中调用processTimeEvents ---> 其会遍历整个链表，找到超时的定时器，然后进行任务回调
    若该定时器对应一个周期事件，那么在任务回调后，更新定时事件，将其再加入链表中
    
    Redis内部的周期事件:serverCron()
    持续运行的Redis服务器需要定期对自身的资源和状态检查和调整 ---> serverCron()的任务
    包括:
     1)更新服务器的各类统计信息，比如内存占用情况，数据库占用情况
     2)清理过期键值对
     3)清理连接失效的客户端
     4)检查服务器是否满足持久化的条件(RDB,AOF)，若满足，就进行持久化
     5)如果服务器是master,那么对slaves进行定期同步
     6)如果处于集群模式，则对集群进行定期同步和连接测试
  
  事件处理都是原子性地 ---> 不会中断事件处理
  若事件处理过于复杂，处理较慢 ----> 后面的事件可能需要很久才会被处理 ---> 饥饿
  可以采用轮转调度的思想，为每次事件处理确定时间上限，超过该时间后，就保存处理现场(不同事件处理可能有不同的现场
  比如server对client的回复事件:其通过write()将buffer写入socket进行回复,可以保存上次写入中断时buffer中的位置，下次接着写)
  然后事件处理主动退出，让后续事件能够得到响应
  或则分配额外的线程或者进程进行事件处理 --> 比如RDB,AOF持久化操作

2.Redis对于两种事件的协调调度
  processEvents(){
    1.获取离当前最近的时间事件，到期时间设为time
    2.调用epoll_wait(xxx,time)进行文件监听
    3.处理到来的文件事件
    4.处理到来的时间事件
  }
  Redis服务器主函数
  main(){
    1.服务器初始化
    2.while server_is_not_stopped 
        processEvents();
    3.关闭服务器
  }

