----------------------------------------------------------------
1.Redis为内存数据库.
  一旦Redis进程退出，数据库中数据也就会消失
  所以需要将内存中的数据持久化到外存中.
  服务器重启时，再将外存中的数据恢复到内存中
  Redis提供两种持久化的手段:RDB和AOF
----------------------------------------------------------------

2.RDB持久化:记录当前数据库所有的数据
  1)RDB文件结构:文件标识+实际数据+文件校验
    REDIS db_version databases EOF check_sum
    a.REDIS
      用于标识该文件是否为RDB文件
    b.db_version
      4字节，记录RDB文件的版本号
    c.databases 
      实际的数据库数据
    d.EOF
      1字节.文件结束标识 ---> 读取RDB文件时，读取到此就OK
    e.check_sum 
      生成RDB文件时，会根据内容生成校验码check_sum
      读取RDB文件时，会根据内容计算校验码
      通过比较两次校验码就可以知道RDB文件是否有损坏
    
    databases结构:在文件中的标识+数据库编号+键值对
    SELECTDB db_number key_value_paris
    a.SELECTDB 
      在文件中的标识 ---> 标识接下来的内容为数据库
    b.db_number 
      数据库编号
    c.key_value_pairs
      键值对

    通过RDB文件进行数据库复原时，也需要知道每个键值对的类型，才能生成对应的redisObejct，再存储在数据库中
    若在将数据保存到RDB之前设置过TTL，那么该TTL也会被记录下来
    key_value_paris结构:
    EXPIRETIME_MS ms TYPE  KEY VALUE 
    EXPIRETIME_MS起到标识作用:告诉接下来的数据(ms 8字节)为TTL

    TYPE标识VALUE的类型
    因为redisObejct不仅有类型，还有该类型的实现编码 ---> REDIS将其存储在TYPE中
    VALUE结构大概为: encoding 每种实现方式的特有数据  数据个数 实际数据
    实际数据的记录结构: 数据大小 数据

    当TYPE为字符串对象，且底层实现为SDS时，REDIS会根据字符串的长度(长度)考虑是否进行压缩
    压缩后的字符串结构为:
    REDIS_RDB_ENC_LZF compressed_len  origin_len    compressed_string
    压缩算法LZF       压缩后的长度    压缩前的长度  压缩后的数据
    读取时，在根据这些信息进行解压缩

    比如列表对象的vaule结构
    list_length item1 ....itemN
    item结构:
    size data
    比如:
    3 5 "hello" 5 "world" 1 "!"

    RDB文件分析:133

----------------------------------------------------------------
  2)RDB文件生成
    client可以通过SAVE或者BGSAVE命令主动请求server生成RDB文件
    a.SAVE
      会阻塞server，直到RDB文件创建完毕.
      server在阻塞期间无法处理命令请求
    b.BGSAVE
      会fork出子进程来创建RDB文件
      创建完以后，子进程向父进程发送信号
      父进程则进行处理命令请求，并继续处理命令请求，轮训子进程发送的信号
    RDB持久化期间，server会拒绝接下来的RDB持久化请求 ----> 避免data race
----------------------------------------------------------------

  3)RDB文件载入
    服务器在启动时，若检测到RDB文件，就会自动载入
    载入期间，服务器是阻塞的，直到载入完成为止
----------------------------------------------------------------
    若服务器开启了AOF持久化功能
    由于AOF文件的更新频率比RDB高，所以更能反应最新的数据，所以服务器会优先载入AOF文件
----------------------------------------------------------------

----------------------------------------------------------------
  4)RDB文件的自动生成
    可以配置服务器,设置RDB文件的保存条件
    为服务器创建定期任务 ---> 检查当前服务器状态是否满足保存条件.若满足就调用BGSAVE
    保存条件可以设置多个，只要其中一个条件被满足，就可以执行BGSAVE
    比如
    save 900 1 : 在900s以内，对数据库至少修改1次
    save 300 10: 在300s以内，对数据库至少修改了10次
    服务器在启动时，就会解析配置文件，生成saveparam数组
    struct saveparam {
      time_t seconds;
      int changes;
    }
   既然有了保存条件，那么就有相应的数据库状态 ---> 状态是否符合条件
   a.lastsave
     对应seconds --> 距离上一次RDB持久化以后，已经过了多少s
   b.dirty
     对应changes --> 距离上一次RDB持久化以后，做了多少修改  ---> 每执行一个修改命令，就会+1

   Redis设有周期性时间事件:serverCron() 
   其中一项任务就是检查当前状态是否满足RDB持久化的条件，若满足，则进行RDB持久化
----------------------------------------------------------------

    

3.AOF持久化
----------------------------------------------------------------
  server端的数据库中的数据是通过执行客户端发送的 写入和修改 命令来建立起来的
  所以也可以通过保存 历来的 写入和修改命令 来完成持久化  
----------------------------------------------------------------

----------------------------------------------------------------
  1)AOF持久化的大致过程
    a.缓存server执行的写命令 ---> 存放到aof_buf中
    b.缓存刷新，将数据写入到文件缓冲区中(调用write())，再考虑是否同步到外存文件中
      刷新时机
       Redis进程的主体为:事件循环.
       事件包括文件事件:接受客户端的命令请求，执行命令，命令恢复
               时间事件:定时任务，定期任务等
       在每次循环中都会调用flsuhAppendOnlyFile() 
       其会根据appendfsync配置选项来决定是否将aof_buf中的数据到文件中
      伪代码:
      eventloop(){
          processFileEvents();
          processTimeEvents();
          flushAppendOnlyFile();
      }

     appendfsync配置的可能值:
     1.always
       总是将aof_buf中的数据写入并同步到AOF文件中
       安全，但很慢
     2.no
       将aof_buf中的数据写入内核文件buffer中
       由OS决定何时将buffer中的数据同步到外存中
       很快，但不安全
     3.everyse
       将aof_buf中的数据写入内核文件buffer中
       如果距离上次同步到AOF文件的时间已经超过1s,就进行文件同步
       在速度和安全方面折中
       速度足够快，而且即使发生宕机，也只损失1s内的数据
----------------------------------------------------------------
      
----------------------------------------------------------------
  2)AOF重写
    随着时间的增长，保存的写入命令会越来越多，AOF文件体积膨胀过度
    但实际上，数据库不一定有相同的增长幅度 ---> 修改命令也算写入命令，但其并不一定增长数据库体积
    而且可能存在命令冗余的情况:比如: RPUSH list A  RPUSH list B --> 其实用一条命令即可:RPUSH list A B
    此时AOF文件就显得臃肿

    于是Redis提供了AOF重写的功能，以精简AOF文件
    AOF重写会生成新的AOF文件来取代旧的AOF文件
    新的AOF文件是通过读取当前数据库的状态来生成的
    比如:
    当前数据库中保存有数据: list A B C D E
    不管该数据之前是通过几条写入命令来实现的
    现在只需要一条命令: RPUSH list A B C D E
  
    若当前列表键元素过多，为了避免aof_buf缓冲区溢出，会进行多次重写
    比如:
    RPUSH list A B C 
    RPUSH list D E

    可见AOF重写会进行大量的写入操作(write())
    若让服务器进程来执行写入操作，则会导致服务器不能再接受客户端的请求
    Redis采取的策略:用子进程进行写入操作
    使用进程而不是线程的好处:不用锁就能保证数据的安全性

    问题:当子进程在进行写入操作时.此时又有写入命令到来，父进程会正常执行 ---> 修改数据库的状态.
         而子进程是不知晓的  ---> 重写后的数据库状态与当前数据状态不一致 

    解决:事后弥补
         在子进程重写期间，在父进程中开辟重写buffer ---> 存放此期间到来的写入命令
         子进程完成重写后，向父进程发送信号
         父进程接受到信号后，调用handler:
         a.将重写buffer中的命令添加到重写AOF文件中
         b.用重写AOF文件原子性地替代旧的AOF文件
         整个过程中只有signal handler会阻塞父进程
----------------------------------------------------------------

  3)AOF文件的载入
    服务器只要重新执行一遍AOF文件中保存的命令就可以恢复服务器的状态
    此处涉及到伪善客户端
