
1.在server端保存着所有client的数据
  client通过网络通信发送命令给server请求操作数据
  在server端为每个client建立了一个内存数据结构:redisClient.
  struct redisServer{
    ....
    redisDb* db;             //db数组
    list* clients;
  }
  struct redisClient{
    ....
    redisDb* db;            //记录client使用的db
  }
  struct redisDb{
    ...
    dict* dict;             //使用字典存储KV.其中K只能为字符串对象.V不做限制
  }
  数据库的增删改查都调用hash表的接口


---------------------------------------------------------------
2.读写键空间时的其他操作 ---> 用于维护数据库
  读取键:
   a.若发现键已过期，那么会先删除过期键，再执行余下操作     ---> 惰性删除
   b.更新其lru属性
  修改键:
   a.server每修改过一次键，dirty计数器就会+1  ---> dirty计数器可触发持久化操作 
   b.如果开启通知了功能，那么在修改键后，server就会按配置发送相应的通知
   c.如果client使用WATCH命令来监视某个键，修改操作会将该键进行标记，从而让事务程序能够注意到键已经修改过
---------------------------------------------------------------


---------------------------------------------------------------
3.为键设置过期时间
  client可以通过命令EXPIRE/PEXPIRE请求server会某个键设置TTL(Time To Live).
  随着时间的流逝，server会不断地清理TTL为0的键
  server如何知道某个键是否已经过期?
  1)在键对象里添加TTL字段 
    server就需要遍历redisDb的中所有数据才能知道哪些键已过期 ----> 这种设计显然不好
  2)单独集中存放设置过TTL的键
    在redisDb含有字段:dict* expires;  
    其保存了设置了TTL的键 
    KV为 <redisObject*,TTL> ----> K为指针，指向dict中的某个键对象 ---> 共享数据，节约内存
    server只需要遍历该字典就可以知道该redisDb哪些键已经过期,以及快速查询某个键是否已经过期

  过期键的判定: 若TTL < now(),则表明键已过期
  过期键的删除策略:
  1)定时删除
    在设置键的TTL时，创建一个timer，当timer过期时回调删除该键
    好处:过期键能够及时删除,释放内存   -----> 但是让过期键多存在一会儿又有什么坏处呢？
    坏处:若过期键比较多，那么timer也就会很多，每个timer对应一个时间事件
         当CPU吃紧时，可能会 花费很多时间在与当前任务无关 的时间事件上

  2)惰性删除
    键过期时并不立马处理，而是在下次使用时检查键是否过期，若过期，则删除 ---> 推迟到键被使用时
    好处:CPU不会在与目标无关的过期键上花费时间
    坏处:过期键积压过多，内存负担重
         而且有可能该过期键不会再被访问到 ---> 一直没有被释放

  3)定期删除
    server定期对数据库进行检查，清理过期键
    1)和2)的折中
    1)会让服务器不停地去处理当前任务无关的过期键的删除 ---> 浪费CPU资源
      而定期删除，则降低操作频率
    2)可能让服务器的内存长期吃紧
      而定期删除，可周期性地释放内存，缓解内存压力

  Redis采取的策略:
    同时使用惰性删除和定期删除
    惰性删除:所有读写数据库的命令在操作数据之间都会调用expireIfNeeded()来检查数据是否已经过期，若过期，则删除键
    定期删除:每隔一定时间，检查各个redisDb中的expires字典，抽取一部分键，检查其是否过期 
             并没有采取遍历来一次性删除
             下一次的定期删除应该在上一次的基础上进行
             所以需要记录上次定期删除时已经检查到哪个redisDb
---------------------------------------------------------------

4.AOF,RDB和复制功能对于过期键的处理
  1)RDB
    通过SAVE命令生成RDB文件时会先检查键是否已经过期.若过期，则不会保存
    server载入RDB文件时，也会对比键的TTL和now()，若键已过期，则不会载入到server中db中
  2)AOF
    AOF存储着历来的操作数据的命令
    所以并不能直接察觉到某个键是否已经过期
    若键因过期而被删除，那么会向AOF文件中追加DEL命令

---------------------------------------------------------------
  3)复制
    slave服务器的过期键删除由master服务器控制
    master删除一个过期键后，会向所有slave发送DEL命令，通知slave也删除该过期键
    slave在执行客户端发送的命令时，即使发现某个键已过期，也不会处理
    slave只有在收到master的DEL命令时才会删除过期键
---------------------------------------------------------------

5.Redis有两种特殊频道 ---> client订阅，server发送通知 
  比如 0号数据库的message键
  1)__keyspace@0__:message
    键message的任何命令执行情况都会发布到该频道的订阅者
  2)__keyevent@0__:DEL
    在0号数据库，对任何键执行了DEL命令都会将消息发送给订阅者
  
  server通过函数 void notifyKeyspaceEvent(int type,char* event, robj* key,int dbid);
  1)type
    通知类型
  2)event 
    事件名称
  3)key
    产生事件的键
  4)dbid
    产生事件的数据库号码

  比如命令 SADD 在添加元素后，发送keyevent通知
  SADD(){
    .........
    notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sadd",c->argv[1],c->db->id)
  }
  而notifyKeyspaceEvent则会通知类型，构建出频道名字，然后调用pubsubPublishMessage()将消息发送给该频道
  比如:
   chan = __keyspace@{dbid}_:{key}
  
