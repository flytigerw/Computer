
1.编写线程安全的类:核心:用synchronizatiohn primitives保护内部状态

2.C++要求developer自己管理对象的生命周期
  当一个对象被多个线程同时看到时，那么对象的销毁时机会变得模糊，可能出现多种race condtition
  1)在delete一个对象时，是否有其他的线程正在执行该对象的成员函数？
  2)如何保证执行成员函数期间，对象不会被另一线程析构?
  3)在调用某个对象的成员函数之前，如何得知其是否还活着?

3.一个线程安全的class的条件
  1)多个线程访问时，其表现出正确的行为
  2)无论os如何调度这些线程，无论这些线程的执行顺序如何，调用段无须额外的同步或其他协调动作
  std::string就不是线程安全的，应要在外部加锁才能供多个线程同时访问

4.对象的构造要做到线程安全的条件:构造期间不能泄露this
  即:
  1)不能在ctor中注册任何回调
  2)不能在ctor中把this传给跨线程的对象,即使在ctor的最后一行也不行 
  若在构造期间将this泄露 ---> 将访问到半成品对象 ---> 后果难料

5.MutexLock只能用于同步本class的其他数据成员的读和写，不能保护析构 ----> 因为mutex_lock成员的生命期最多与对象一样长，当调用到基类dctor时，派生类对象的那部分已经被delete ---> 基类对象拥有的MutexLock不能保护整个析构过程
