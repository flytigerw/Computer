



1.ELF可执行文件在Linux下的装载
  指令和数据必须装入内存中才能正常运行
  装入方式:
   1)一次性全部装入
     内存有限，无法装入多个进程

   2)动态装入
     利用程序的局部性原理，只将最常用的部分的驻留在内存中
                           不常用的部分则先停留在磁盘中
                           等需要时，再装入内存.内存紧张时，又可被swap出去

2.动态装入分为覆盖装入和页映射
  覆盖装入需要程序员手动计算各个模块之间的调用关系，进程A可覆盖与其具有非调用关系的进程的内存 --> 适用于嵌入式系统
  页映射:结合虚拟存储+MMU


3.进程的建立的要点:
  1)在内存中为其建立虚拟存储空间  
    即创建多个虚存区(VMA)，其尚不会与物理内存页面建立映射关系

  2)读入可执行文件头，建立虚拟存储空间和可执行文件间的映射关系
    即让VMA 都知道自己对应可执行文件中的哪一部分
    CPU给出虚拟地址，通过MMU进行映射转换时，若发现其对应的页面没有位于内存中，就会产生缺页异常
    缺页异常处理程序先找到虚拟地址所属的VMA
    然后根据VMA和可执行文件的映射关系，将可执行文件中对应的内容装入到内存页面中
    再建立 VMA中的虚拟页面 与内存页面的映射关系

    在程序运行过程中，会扩展栈VMA，堆VMA，也可以由用户通过mmap()创建新的VMA 
    大部分VMA都会和某个文件建立映射关系(可执行文件，swap文件，mmap指定的文件等)

  3)将CPU的指令寄存器设置为可执行文件的入口地址(保存在ELF文件头中)，启动运行

                        
4.在装载可执行文件时，通常为文件中的每个段都分配一个VMA，
  若段的大小不是页大小的正数倍，则对应的VMA会向上调整为页大小的正数倍  --> 在实际映射时，可能就需要为段尾的少部分内容分配一张完整的内存页 --> 内存浪费
  解决方法:将 可执行文件中具有相同权限的段的VMA合并为一个
           比如:.text大小为4097字节 --> 需要两个页面大小的VMA
                .init大小为512字节  --> 需要一个页面大小的VMA
                二者都是 可读且可执行的.
                若二者合并，则合并后大小为4609字节 --> 只需要两个页面大小的VMA
  为此，ELF文件中引入了Segment:链接时，链接器会将多个具有相同权限属性的Section分配在同一个空间，形成一个Segment
                               比如代码Segment的特点:可读可执行
                                   数据Segment的特点:可读可写
                               装载时，以Segment为单位建立VMA
  可使用readelf -l xx查看可执行文件中的Segment划分
  在链接时，目标文件中的段称为Section
  在装载时，可执行文件中的段称为Segment

  在ELF类型的可执行文件和共享库文件中，含有Program Header Table --> 保存各个Segment的信息 --> 165页

                
  通过cat /proc/pid/maps 查看进程的虚拟空间分布情况

5.段地址对齐 168页
  程序运行时的环境变量和执行参数的位置 --> 172页
      

