1.计算机中的硬件:CPU,内存,外设控制器
  三者都挂在总线上
  外设控制器可以缓存外设上的数据，然后将大量已缓存的数据发送到总线上，以此来平衡总线和外设之间的速度差异
  外设总线分类:
  1)PCI高速总线
    高速外设挂在上面(比如图显，USB)
    该总线通过北桥芯片与更高速的设备交互:内存总线，CPU总线
    北桥芯片类似外设控制器
  2)ISA低速总线
    低速外设挂在上面(比如网卡，声卡)
    该总线通过南桥桥芯片挂在PCI高速总线上

  整体结构: 第7页

2.访问磁盘时，只需给出逻辑扇区号，磁盘控制器可将其转为实际的扇区位置(盘面，磁道，扇区号)

3.线程资源:线程ID,当前指令指针PC,运行时的工作区:栈+寄存器
           TLS(Thread Local Storage)

4.IO密集性线程 :会频繁地等待IO完成
  CPU密集性线程:IO任务少
  常见的线程调度:(轮转调度+优先级调度)
  1)每个线程都被分配了一个时间片
    时间片耗尽后，线程会被强制性地从CPU换出
    然后根据调度策略将另一个线程载入CPU中
  2)每个线程都有一个优先级,高优先级的线程会优先被调度
  3)优先级可以人为设置,也可由内核根据线程的运行情况自动设置
    比如:若一个线程频繁的进入IO等待状态，则表明其是IO密集性线程，可提升其优先级
         若一个线程等待过久，也会提升其优先级.以避免starvation

5.函数被重入:函数还没有执行完毕，由于外部因素或内部调用，又一次进入该函数执行
  比如:1)多个线程并发执行该函数
       2)函数递归调用自身

  函数可重入:函数被重入后产生的结果 与 函数没被重入而产生的结果是一致的
        特点:并发安全
  比如函数:
  int sqr(int x){
    return x*x;
  }
  函数特点:数据修改只涉及到局部变量  ---->  非共享

  可重入函数的必备条件:
  1)在函数内部不修改全局变量或静态变量  ----> 二者都具有共享性
    const只读变量并发安全

  2)函数不通过 引用或指针 参数来修改调用方的数据
    将引用或指针参数设为const即可

  3)不调用不可重入的函数

6.volatile用于阻止编译器的过度优化
  1)编译器为了提高速度会将变量缓存到寄存器中
    CPU读取变量时就会先从寄存器中读取，修改完的变量也会先放到寄存器中(稍后可被CPU快速获取)
    在多线程情景下可能就会产生并发安全问题,比如
    T1:             T2:
    x = 0;          x = 0;
    lock();         lock();
    ++x;            ++x;
    unlock();       unlock();
    other           other
    编译器在生成代码时，可能先将变量x=0保存到各个线程中的寄存器中
    当T1执行到other时,x=1,但并没有立马写回内存
    T2获得锁开始执行，其会从寄存器中读取到变量x=0 --> 并没有反映x的最新情况
    ++x后得到x=1,其可能也并没有立马写回内存

    最终，不管T1和T2的x写回内存的顺序如何，x都只能为1 --> 与实际情况不符

    用volatile修饰变量x可保证:变量x修改后会立马写回内存
                              变量x的读取都是从内存中读取 --> 可以反映x的最新情况
  
  2)编译器为了效率 可以交换两条毫不相关的指令的执行顺序
    比如:
    x=y=0;       
    T1:             T2:
    1:x=1;          3:y=1;
    2:r1=y;         4:r2=x;
    r1和r2不可能同时为0

    可能交换为:
    T1:             T2:
    1:r1=y;         3:y=1;
    2:x=1;          4:r2=x;
    r1和r2可能同时为0 --> 执行顺序为:1342

    用volatile修饰变量，可阻止编译器调整volatile变量的执行顺序
    
7.CPU的乱序调度也会使得指令的执行顺序发生改变，从而引发并发问题
  比如单例模式:
  T* get_instance(){
    if(!p){     //让后续批次的线程不用加锁
      lock();  //第一批可能有多个线程并发地创建单例 --> 互斥进行
      if(!p){  //线程醒来，发现单例已经创建，不再创建
        p = new T;
      }
      unlock();
    }
    return T;
  }
 
 关键点:p = new T含有三个步骤:
 1)申请内存
 2)在该内存上调用构造函数
 3)将内存地址交给p
 由于CPU的乱序执行，导致2)和3)可能颠倒
 于是有:线程1在临界区先执行3)
        然后切换到线程2
        线程2执行到 if(!p)时，发现p并不为空，于是返回p.但此时p指向未构造的内存，直接访问会引起程序崩溃

 解决:添加内存屏障.其可以防止 指令的交换 越过屏障(屏障前的指令不会交换到屏障后，屏障后的指令不会交换到屏障前)
 T* temp = new T;
 barrier();
 p = temp;

