1 操作系统:完整的软件包。
           管理硬件的核心层软件---内核
           附带的标准软件工具，比如命令行解释器，图形用户界面等

2 内核职责
 1)进程调度:Linux属于多用户抢占式多任务系统
            多个任务可以同时驻留于内存中，哪一个任务抢占CPU的资源呢?
 2)内存管理:进程之间以及进程和内核之间各自所占的内存需要相互隔离
            每个进程只保留一部分在内存中--->降低进程对内存的需求--->RAM可同时加载多个进程--->任意时刻，CPU至少运行一个进程--->提高CPU利用率
 3)提供文件系统
 4)创建和终止进程:内核将程序加载到内存中，为其分配资源，调度执行
                  进程终止时，内核负责资源回收
 5)对外设的访问
 6)联网:内核以用户进程的名义收发网络消息
 7)提供系统调用API

3 有些操作只有在内核态完成，比如硬件操作
  
4 内核是运行系统的中枢。
  掌控着进程的生命周期----->进程本身不能掌控自己
  对进程进行调度，控制进程间的通信

5 shell:命令解释器。读取用户输入的命令，解释并执行之
  login shell:指用户登录系统时，创建shell的进程

6 linux为多用户系统--->每个用户用UID进行唯一标识，多个用户可形成用户组。

7 IO通用性概念:同一套系统调用(open,read,write,close)可用于所有文件类型，包括设备文件
  用户的IO请求，内核将其转为相应文件类型的操作，比如转为设备驱动程序操作
  IO系统调用通过文件描述符(非负整数)来指代打开的文件
  由shell启动的进程会继承3个文件描述符: 0--stdin,1-stdout,2-stderr-----默认都指向终端

8 进程的内存布局
  代码:程序的指令
  数据:程序的静态变量
  堆  :动态分配的额外内存
  栈  :随函数调用，返回而增减的内存。存储局部变量和函数的链接信息

9 进程创建:fork
  内核通过复制父进程来创建子进程
  子进程继承父进程的数据，堆，栈段
  与父进程共享代码段
  子进程要么去执行共享代码段中的另一组不同的函数
  或者调用execve(),销毁继承和共享的内容,加载新程序的代码

10 进程终止
 1)进程调用exit()请求退出
 2)向其发信号,将其kill
 进程终止时，生成终止状态----->供父进程的wait()检测
 终止状态:保存在shell变量$?中
 0--->表示功成身退
 other-->有错误发生
            
11 每个进程都有一组与之相关的UID和GID
 1)真实UID和GID:标识进程所属的用户和用户组
   新进程继承父进程的GID
   login shell则从系统密码文件中的相应字段中获取
 2)有效UID和GID:进程访问受保护资源时，如文件。可通过该ID来确定访问权限
   修改进程的有效ID,可以使进程访问其他用户的资源

12 将超级用户的权限划分为一组相互独立的capabilities.
   当进程拥有某capability时，就可以执行相应的特权操作

13 init进程:系统引导时创建
   所有进程之父
   程序文件:/sbin/init
   进程号为1，以超级用户权限执行。只有系统关闭才能kill该进程
   主要任务:创建并监控系统运行所需的一系列进程

14 守护进程
   含有特殊用途
   通常在系统引导时启动，直至系统关闭
   在后台运行，终端无法控制其读取和输入

15 环境列表:在进程用户空间内存中维护的一组环境变量
   在shell中,通过export创建环境变量 export xx='yy'
   C语言程序可通过 char** environ访问环境变量

16 内存映射
  进程调用mmap(),为其在虚拟地址空间中创建一个新的内存映射
  文件映射:将文件的部分区域映射入进程的虚拟内存中
           对该文件映射的访问将转为对应的内存区域操作
           映射页面按需从文件中加载
  进程A和B可映射相同的内存区域中
  1)两个进程针对某一文件的相同部分进行映射
  2)由fork()创建的子进程自父进程处继承映射
  多个进程共享内存页面时,进程之一对页面的改动是否能被其他进程所见?--->根据创建映射时的标志而定
   1)私有--->其他进程不可见，改动不会真地落实到文件上
   2)共享--->可见，会造成文件的改动

17 静态库和共享库
    静态库:对已编译的目标模块的结构化整合
    若要使用静态库的函数，则必须在链接命令指定相应的库
    主程序会引用该函数在静态库中隶属的目标模块
    链接器解析引用情况后，会从静态库中抽取所需目标模块的副本，将其copy到最终的可执行文件中
    缺点:最终的可执行文件可能会很大---->造成内存和外存的浪费
         修改程序依赖的静态库以后，整个程序都需要重新编译

    动态库:若程序链接到动态库，则会在可执行文件中进行记录，表明需要动态库的内容
           在运行时，动态链接器负责找到程序所需的动态库，将其载入内存，实施运行时链接

18 InterProcess Communication(IPC)机制
   管道，socket，文件锁定，消息队列，信号量，共享内存
   信号:软件中断
   内核可向进程发送信号，进程也可以向进程发送信号
   信号可以被挂起
    1)接收进程处于挂起状态。在获得下次调度时，挂起的信号也将送达
    2)程序可将信号纳入 信号屏蔽 之列中。信号将挂起直至解除信号的阻塞

13 进程中的多线程共享同一数据区域和堆
   但每个线程有自己的栈，用于保存局部变量和函数调用的链接信息
   多线程可通过共享全局变量来通信-->方便
   多线程应用可从多处理器硬件的并行处理中受益匪浅

14 支持任务控制的shell 
   比如命令: ls -l | sort -k5n | less
   管道内的所有进程置于一个进程组中，含有相同的进程组ID--->组长进程ID
   可对进程组的所有成员执行相同的动作----->信号传递

15 session:指的是一组 进程组
   session leader--->创建session的进程
   比如支持 任务控制的shell--->shell可创建很多进程组，shell就为session leader

   session通常与某个控制终端相关
   控制终端建立与于 session leader 初次打开终端设备之时-->比如shell打开登录终端-->shell成为终端的控制进程-->若与终端断开链接，控制进程会收到 SIGHUP 信号
   一个终端只能成为一个session的控制终端
   在任意时点，session中总会有一个前台进程组--->接收终端输入以及输出到终端
   用户可在控制终端输入 <C-c> ,终端驱动程序会发送信号来挂起前台进程组
   session中也可以有若干后台任务
   支持任务控制的shell提供如下命令:
    列出所有任务，向任务发信号，前后台任务的来回切换

16 伪终端
   一对相互连接的虚拟设备,有一条IPC信道，可供数据双向传递-->主从设备
   从设备提供的接口的 行为方式 与终端类似------>可将某个为终端编写的程序与从设备"挂钩"----->"面向终端"的程序
   主设备则与另一程序"挂钩"--->该程序可驱动"面向终端"的程序--->通过IPC信道传递数据--->而"面向终端"的程序也将内容通过IPC信道输出到主设备程序
   主设备就类似传统终端，主设备程序就类似shell
   应用:telnet和ssh的网络登录服务应用
        x window系统提供的终端窗口

17 /proc文件系统
  虚拟文件系统
  以文件系统的 目录和文件 形式，提供一个指向内核数据结构的接口---->方便查看和改变各种系统属性，也能通过/proc/PID的目录查看系统中运行各进程的相关消息

