
<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in C++<BR>
Chapter 17, Exercise 9<BR>
<BR>
</H1>

<dl compact>
<dt> (a)
<dd>
The completion times are <code class=var>(4, 6, 14, 15)</code>.
So, the ACT is <code class=var>(4 + 6 + 14 + 15) / 4) = 9.75</code>.
<br><br>
<dt> (b)
<dd>
When the task order is <code class=var>2</code>, <code class=var>1</code>, <code class=var>4</code>, <code class=var>3</code>, the completion times are
<code class=var>(2, 6, 7, 15)</code>.  Now, the ACT is <code class=var>(2 + 6 + 7 + 15) / 4 = 7.5</code>.
<br><br>
<dt>(c)
<dd>
For the greedy order <code class=var>4</code>, <code class=var>2</code>, <code class=var>1</code>, <code class=var>3</code>, the completion times are
<code class=var>(1, 3, 7, 15)</code>.  The ACT for this order is <code class=var>26 / 4 = 6.5</code>.
<br><br>
<dt>(d)
<dd>
The greedy strategy can be implemented in <code class=var>n log n</code>
time by using an <code class=var>O(n log n)</code> sorting algorithm to first
sort the tasks into ascending order of task time.  This sorted order
is the order in which the tasks are to be done.
<!--
The code to minimize the ACT is given below.

<HR class = coderule>
<pre class = code>
public class AverageCompletionTime
{
   // top-level nested class
   static class Task implements Comparable
   {
      // instance data members
      int time;                  // task length
      int id;                    // task id

      // constructor
      Task(int theTime, int theId)
      {
         time = theTime;
         id = theId;
      }

     // method of Comparable
     /** return true iff this &lt; x */
     public int compareTo(Object x)
     {
        int xTime = ((Task) x).time;
        if (time &lt; xTime)
           return -1;
        if (time == xTime)
           return 0;
        return 1;
      }
  
     /** return true iff this == x */
     public boolean equals(Object x)
        {return time == ((Task) x).time;}
     }

   
   /** reorder the tasks task[1:task.length-1] so that the
     * average completion time is minimized */
   public static void minimizeAverageCompletionTime(Task [] task)
      {HeapSort.heapSort(task);}
}
<hr class=coderule>
</pre>
<br><br>

The code and a sample test can be found in the files
<code class=var>AverageCompletionTime.*</code>.
--!>
<br><br>
<dt>(e)
<dd>
Since there are only <code class=var>n!</code> orders in which the
<code class=var>n</code> tasks can be done,
there must be one with minimum ACT.  Let <code class=var>S</code> denote the order that
gives minimum ACT.
Consider the tasks in the order given by <code class=var>S</code>.
Suppose there is an <code class=var>i</code> for which
<code class=var>t<sub>i</sub> &gt;
t<sub>i+1</sub></code>.  Let <code class=var>A = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>i-1</sub></code>.
The ACT of <code class=var>S</code> is
<br><br>
<code class=var>
((c<sub>1</sub> + ... + c<sub>i-1</sub>) + c<sub>i</sub> + c<sub>i+1</sub> +
(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n
<br>
= ((c<sub>1</sub> + ... + c<sub>i-1</sub>) + A + t<sub>i</sub> + A + t<sub>i</sub> + t<sub>i+1</sub> +
(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n
<br>
=
((c<sub>1</sub> + ... + c<sub>i-1</sub>) + 2A + 2t<sub>i</sub> + t<sub>i+1</sub> +
(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n</code>.
<br><br>
If we swap tasks
<code class=var>i</code> and
<code class=var>i+1</code>, the ACT becomes
<code class=var>
((c<sub>1</sub> + ... c<sub>i-1</sub>) + 2A + t<sub>i</sub> + 2t<sub>i+1</sub> +
(c<sub>i+2</sub> + ... + c<sub>n</sub>)) / n</code>.
Since <code class=var>t<sub>i</sub> &gt;
t<sub>i+1</sub></code>, the ACT is reduced as a result of the swap.
So, <code class=var>S</code> does not have minimum ACT.  This contradicts the assumption that
<code class=var>S</code> has minimum ACT.  So, there can be no
<code class=var>i</code>, in <code class=var>S</code>,
for which
<code class=var>t<sub>i</sub> &gt;
t<sub>i+1</sub></code>.  As a result, the tasks in
<code class=var>S</code> are in nondecreasing
order of task times.
<br><br>
When several tasks have the same task time, the relative order of these
does not affect the ACT.  So, any sorted order may be used.  As a result,
the task order generated by the greedy strategy of (c)
has minmum ACT.


</FONT>
</BODY>
</HTML>
