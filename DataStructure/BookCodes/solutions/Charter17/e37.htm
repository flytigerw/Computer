<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in C++<BR>
Chapter 17, Exercise 37<BR>
<BR>
</H1>


<dl compact>
<dt> (a)
<dd>
We may prove that Prim's algorithm of Figure 17.13
always constructs a minimum-cost spanning tree by
using the transformation technique
used for the loading problem as well as for the proof of
correctness of Kruskal's method.  We need to establish the following:
(1) Prim's method results in a spanning tree whenever a
spanning tree exists, and (2)
the spanning tree generated is of minimum cost.
<br><br>

Let <code class=var>G</code> be any weighted undirected graph
(i.e., <code class=var>G</code>
is an undirected network).
From Section 17.9.3, we know that an undirected
graph has a spanning tree iff it is connected.
Prim's method fails only if there are no edges connecting
vertices in <code class=var>TV</code> with those not in
<code class=var>TV</code>, a condition that arises only if the
graph is not connected.
<br><br>

Now let us prove that the constructed spanning
tree <code class=var>T</code> is of minimum cost.
Since <code class=var>G</code> has a finite number of spanning trees, it has at
least one of minimum cost.  Let <code class=var>U</code> be such a minimum-cost spanning tree.
Both <code class=var>T</code> and
<code class=var>U</code> have exactly
<code class=var>n-1</code> edges.  If
<code class=var>T = U</code>,
then <code class=var>T</code>
is of minimum cost and we have nothing to prove.  Therefore, assume that
<code class=var>T != U</code>.  Let
<code class=var>k</code>,
<code class=var>k &lt; n-1</code>, be such that the first
<code class=var>k</code> edges added to
<code class=var>T</code> are also in
<code class=var>U</code> and the
<code class=var>k+1</code>th edge added to
<code class=var>T</code> is not in
<code class=var>U</code>.
<br><br>
We shall show that <code class=var>T</code> and
<code class=var>U</code> have the same cost by transforming
<code class=var>U</code> into
<code class=var>T</code>.  This transformation will be done
in at most <code class=var>n-1-k</code>
steps.  At each step the value of <code class=var>k</code> is increased
by at least <code class=var>1</code>.
Further, the cost of <code class=var>U</code> will not change
as a result of the transformation.  Consequently,  after at most
<code class=var>n-1-k</code> steps of
transformation <code class=var>U</code> will have the same cost as the
initial <code class=var>U</code> and will
consist of exactly those edges that are in <code class=var>T</code>.  Therefore,
<code class=var>T</code>
is of minimum cost.
<br><br>
Each step of the transformation involves
adding to <code class=var>U</code> one edge,
<code class=var>e</code>, from
<code class=var>T</code> and
removing one edge, <code class=var>f</code>, from
<code class=var>U</code>.
The edges <code class=var>e</code> and <code class=var>f</code> are selected
in the following way:
<OL>
<LI>
Let <code class=var>e</code> be the <code class=var>k+1</code>th edge added to <code class=var>T</code>.  By definition of
<code class=var>k</code>, this edge is not in <code class=var>U</code>.
Let <code class=var>TV</code> be the set of vertices in the tree just before
edge <code class=var>e</code> is added.
Let <code class=var>R</code> be the set of remaining vertices.
<code class=var>e</code> joins a vertex in
<code class=var>TV</code> and one in
<code class=var>R</code>.
<LI>
When <code class=var>e</code> is added to <code class=var>U</code>, a unique cycle
is created.
Let <code class=var>f</code>
be an edge, other than <code class=var>e</code>, on this cycle that joins a vertex in
<code class=var>TV</code> with one in <code class=var>R</code>.  Such an <code class=var>f</code> must exist as the edges on
this cycle, other than <code class=var>e</code>, form a path between a vertex in
<code class=var>TV</code>
and one in <code class=var>R</code>.
Note that <code class=var>f</code> is not one of the first
<code class=var>k+1</code> edges added to
<code class=var>T</code> because at the time
<code class=var>e</code>, which is the
<code class=var>k+1</code>th edge added to
<code class=var>T</code>, is added there is no edge in
<code class=var>T</code> that joins a vertex in
<code class=var>TV</code> and one
in <code class=var>R</code>.
</OL>
<br><br>
From the way <code class=var>e</code> and <code class=var>f</code> are selected,
it follows that <code class=var>V =
U + {e} - {f}</code>
is a spanning tree and that at least the first <code class=var>k+1</code>
edges added to <code class=var>T</code> are in
<code class=var>V</code>.  We need to show that the cost of
<code class=var>V</code> is the same as that of
<code class=var>U</code>.
Clearly, the cost of <code class=var>V</code> is the cost of
<code class=var>U</code> plus the cost of edge
<code class=var>e</code>
minus the cost of edge <code class=var>f</code>.  If the cost of
<code class=var>e</code> is less than the cost
of <code class=var>f</code>, then the spanning tree
<code class=var>V</code> has a smaller cost than the tree
<code class=var>U</code>, which is impossible.  If
<code class=var>e</code> has a higher cost than
<code class=var>f</code>, then
<code class=var>f</code> would have been added to
<code class=var>T</code>
before <code class=var>e</code> by Prim's algorithm.
But it was not.  So edges <code class=var>e</code> and <code class=var>f</code>
must have the same cost.
Hence <code class=var>V</code> has the same cost
as <code class=var>U</code>.
<br><br>

<dt> (b)
<dd>
Let <code class=code>e</code> be the number of edges in the graph.
We may assume that <code class=code>e >= n - 1</code>; otherwise,
the graph is not connected and so has no spanning tree.
It is possible to implement Prim's method so as to have complexity
<code class=code>O(e + n log n)</code>.
Such an implementation
requires the use of the adjacency list representation of a graph
as well as the data structure Fibonacci Heap which we
have not studied in this book.  An <code class=code>O(e log n)</code>
implementation is possible when the graph is represented
using adjacency lists and we employ a min heap
to assist in the selection of edges.
When an adjacency matrix is used in
conjunction with a min heap, the resulting implementation has
complexity <code class=code>O(n<sup>2</sup> + e log n)</code>.
Replacing the use
of the modified min heap with a Fibonacci heap will result in an
<code class=code>O(n<sup>2</sup>)</code> complexity when adjacency
matrices are used and an <code class=code>O(e + n log n)</code> complexity
when adjacency lists are used.
By using the strategy employed in the single-source all-destinations shortest
paths solution of Program 17.3 (i.e., maintain a list of vertices not yet included in
the spanning tree, on each round select the vertex that is closest to
a selected vertex), we obtain an <code class=code>O(n<sup>2</sup>)</code>
implementation.
This
<code class=code>O(n<sup>2</sup>)</code> implementation is the
best implementation
to use when the graph has <code class=code>O(n<sup>2</sup>)</code> edges.
When the number of edges is <code class=code>O(n)</code>, for example, it
is advantageous to use adjacency lists together with a
min heap.
When the number of edges is <code class=code>O(n<sup>1.5</sup>)</code>, for example, it
is advantageous to use adjacency lists together with a
Fibonacci heap.
<br><br>
Regardless of whether we use a Fibonacci heap, a min heap, or a
chain of unselected vertices, the basic implementation strategy
is the same.
We begin by adding vertex <code class=var>1</code>
to the set of selected vertices, that is
the vertices in <code class=var>TV</code>.  We go through
<code class=code>n-1</code> stages.  In each of these, a new vertex
is selected.  This vertex is the one that is nearest to an already
selected vertex (i.e.,  it is a vertex that is not in <code class=var>TV</code>
and is connected to a vertex in <code class=var>TV</code> with the
least cost edge).  To make this selection, we define, for every
vertex <code class=var>v</code> not in <code class=var>TV</code>, 
a distance which equals the cost of the least cost edge
that joins this vertex to any vertex in <code class=var>TV</code>.
At each stage, the vertex with least distance is selected.
<br><br>
Suppose that vertex <code class=var>v</code> is selected, its inclusion
into <code class=var>TV</code> may reduce the distance values of its
adjacent vertices that are currently not in <code class=var>TV</code>.
So we need to perform the operations: select the minimum distance
vertex and decrease some distance values.  Alhough these operations
are done best using a Fibonacci heap, they are done fairly efficiently
using either (1) a min heap which is augmented by an array
<code class=code>location</code> to keep track of the
location in <code class=code>heap[]</code> of the distance
value of a vertex or (2) a chain and a distance array as used
in the shortest paths solution of Program 17.3.
<br><br>
<br><br>
<!--
First, we develop the implementation
that uses a min heap. We begin by
defining the class <code class=code>ModifiedMinHeap</code>
as below.
The invocation <code class=code>decreaseWeight(x)</code> replaces the
old distance (weight) of vertex <code class=code>x.vertex</code>
by the smaller value <code class=code>x.weight</code>.
The method <code class=code>initialize</code> has not been implemented.
Although the code given below stores weighted edge nodes in the min heap,
it is sufficient to store only the weights.


<HR class = coderule>
<pre class = code>
public class ModifiedMinHeap
{
   // data members
   WeightedEdgeNode [] heap;   // array for complete binary tree
   int [] location;            // current location of an element
   int size;                   // number of elements in heap

   // constructors
   /** create a heap with the given initial capacity */
   public ModifiedMinHeap(int initialCapacity)
   {
      if (initialCapacity &lt; 1)
         throw new IllegalArgumentException
                   ("initialCapacity must be &gt;= 1");
      heap = new WeightedEdgeNode [initialCapacity + 1];
      location = new int [initialCapacity + 1];
      size = 0;
   }
   
   /** create a heap with initial capacity 10 */
   public ModifiedMinHeap()
      {this(10);}

   // methods
   /** @return true iff the heap is empty */
   public boolean isEmpty()
      {return size == 0;}

   /** @return number of elements in the heap */
   public int size()
      {return size;}

   /** @return minimum element
     * @return null if the heap is empty */
   public WeightedEdgeNode getMin()
   {
      if (size == 0)
         return null;
      else
         return heap[1];
   }

   /** put theElement into the heap */
   public void put(WeightedEdgeNode theElement)
   {
      // increase array size if necessary
      if (size == heap.length - 1)
         heap = (WeightedEdgeNode []) ChangeArrayLength.changeLength1D
                                    (heap, 2 * heap.length);
   
      // find place for theElement
      // i starts at new leaf and moves up tree
      int i = ++size;
      while (i != 1 &amp;&amp; ((Comparable) heap[i/2].weight)
                         .compareTo(theElement.weight) &gt; 0)
      {
         // cannot put theElement in heap[i]
         heap[i] = heap[i/2]; // move element down
         location[heap[i].vertex] = i;
         i /= 2;              // move to parent
      }
   
      heap[i] = theElement;
      location[theElement.vertex] = i;
   }
   
   /** remove min element and return it */
   public WeightedEdgeNode removeMin()
   {
      // if heap is empty return null
      if (size == 0) return null;       // heap empty
   
      WeightedEdgeNode x = heap[1];           // min element
      location[x.vertex] = 0;
   
      // restucture heap
      WeightedEdgeNode y = heap[size--];      // last element
   
      // find place for y starting at root
      int i = 1,  // current node of heap
          ci = 2; // child of i
      while (ci &lt;= size)
      {
         // heap[ci] should be smaller child of i
         if (ci &lt; size &amp;&amp; ((Comparable) heap[ci].weight)
                            .compareTo(heap[ci+1].weight) &gt; 0)
                               ci++;
   
         // can we put y in heap[i]?
         if (((Comparable) y.weight).compareTo(heap[ci].weight) &lt;= 0)
            break;   // yes
   
         // no
         heap[i] = heap[ci];             // move child up
         location[heap[i].vertex] = i;
         i = ci;                         // move down a level
         ci *= 2;
      }
      heap[i] = y;
      location[y.vertex] = i;
   
      return x;
   }
   

   /** decrease weight of x.vertex to x.weight */
   public void decreaseWeight(WeightedEdgeNode x)
   {
      // check if x.vertex in heap
      if (location[x.vertex] == 0)
         // not in heap
         throw new IllegalArgumentException
                   ("illegal id value");
   
      // make sure new distance is smaller
      if (((Comparable) x.weight)
            .compareTo(heap[location[x.vertex]].weight) &gt;= 0)
         throw new IllegalArgumentException
           ("new distance value must be less than old one");
   
      // find new place for x
      // i starts at old location of x and moves up tree
      int i = location[x.vertex];
      while (i != 1 &amp;&amp; ((Comparable) x.weight)
                         .compareTo(heap[i/2].weight) &lt; 0)
      {// cannot put x in heap[i]
         heap[i] = heap[i/2];              // move element down
         location[heap[i].vertex] = i;
         i /= 2;                           // move to parent
      }
      heap[i] = x;
      location[x.vertex] = i;
   }
}
<hr class=coderule>
</pre>
<br><br>

The code for Prim's method now takes the form
given below (this code is commented out in the file <code class=code>Graph.java</code>).

<HR class = coderule>
<pre class = code>
public class PrimWithMinHeap
{
   /** find a min cost spanning tree using Prim's method
     * @return false iff the weighted undirected graph is not connected
     * @param t[0:n-2] has the min cost tree edges when done */
   public boolean prim(WeightedEdge [] t)
   {
      verifyWeightedUndirected("prim");
   
      int n = vertices();
      boolean [] selected = new boolean [n + 1];
              // selected[i] is true iff vertex i already in spanning tree
      WeightedEdgeNode [] nearNbr = new WeightedEdgeNode [n + 1];
              // nearNbr[i].vertex is nearest spanning tree neighbor of vertex i
              // nearNbr[i].weight is distance to this nearest neighbor
   
      // start with vertex 1 in the spanning tree
      // initialize nearNbr and modified min heap of candidates
      selected[1] = true;
      ModifiedMinHeap h = new ModifiedMinHeap (n);
      Iterator iv = iterator(1);  // vertices adjacent to vertex 1
      while (iv.hasNext())
      {
         WeightedEdgeNode we = (WeightedEdgeNode) iv.next();
         nearNbr[we.vertex] = new WeightedEdgeNode(1, we.weight);
         h.put(we);
      }
   
      // select n-1 edges for spanning tree
      for (int i = 0; i &lt; n - 1; i++)
      {
         // get nearest unselected vertex
         WeightedEdgeNode we = h.removeMin();
         if (we == null)
            // no unselected neighbor remains
             return false;
   
         // select we.vertex
         t[i] = new WeightedEdge(we.vertex, nearNbr[we.vertex].vertex,
                                 we.weight);
         selected[we.vertex] = true;
   
         // update distances
         iv = iterator(we.vertex);
         while (iv.hasNext())
         { 
            WeightedEdgeNode w = (WeightedEdgeNode) iv.next();
            if (!selected[w.vertex])
            {
               if (nearNbr[w.vertex] == null)
               {// w.vertex not in min heap
                  nearNbr[w.vertex] = new WeightedEdgeNode(we.vertex, w.weight);
                  h.put(w);
               }
               else
                  // w.vertex is in the min heap
                  if (((Comparable) nearNbr[w.vertex].weight)
                        .compareTo(w.weight) &gt; 0)
                  {// found a closer neighbor
                     nearNbr[w.vertex].weight = w.weight;
                     nearNbr[w.vertex].vertex = we.vertex;
                     h.decreaseWeight(w);
                  }
            }
         } 
      }   
   
      // spanning tree found
      return true;
   }
}
<hr class=coderule>
</pre>
<br><br>
When we use a chain as is done in Program 17.3, we get the implementation
shown below (this code is in the file <code class=code>Graph.java</code>).
<HR class = coderule>
<pre class = code>
/** find a min cost spanning tree using Prim's method
  * @return false iff the weighted undirected graph is not connected
  * @param t[0:n-2] has the min cost tree edges when done */
public boolean prim(WeightedEdge [] t)
{
   verifyWeightedUndirected("prim");

   int n = vertices();
   boolean [] selected = new boolean [n + 1];
           // selected[i] is true iff vertex i already in spanning tree
   WeightedEdgeNode [] nearNbr = new WeightedEdgeNode [n + 1];
           // nearNbr[i].vertex is nearest spanning tree neighbor of vertex i
           // nearNbr[i].weight is distance to this nearest neighbor

   // start with vertex 1 in the spanning tree
   // initialize nearNbr and list of unselected adjacent vertices
   selected[1] = true;
   GraphChain l = new GraphChain(); // list of unselected adjacent vertices
   Iterator iv = iterator(1);  // vertices adjacent to vertex 1
   while (iv.hasNext())
   {
      WeightedEdgeNode we = (WeightedEdgeNode) iv.next();
      nearNbr[we.vertex] = new WeightedEdgeNode(1, we.weight);
      l.add(0, new EdgeNode(we.vertex));
   }

   // include remaining vertices into the spanning tree using Prim's method
   int i = 0;  // number of edges in spanning tree
   while (!l.isEmpty())
   {// there is an adjacent unselected vertex
      // find adjacent unselected vertex v with least edge cost
      Iterator il = l.iterator();
      int v = ((EdgeNode) il.next()).vertex;
      while (il.hasNext())
      {
         int w = ((EdgeNode) il.next()).vertex;
         if (((Comparable) nearNbr[w].weight)
               .compareTo(nearNbr[v].weight) &lt; 0)
            v = w;
      }

      // select vertex v and associated edge
      t[i++] = new WeightedEdge(v, nearNbr[v].vertex, nearNbr[v].weight);
      selected[v] = true;

      // delete v from l and update nearNbr
      l.removeElement(v);

      // update distances
      iv = iterator(v);
      while (iv.hasNext())
      { 
         WeightedEdgeNode w = (WeightedEdgeNode) iv.next();
         if (!selected[w.vertex])
         {
            if (nearNbr[w.vertex] == null)
            {// w.vertex not in min heap
               nearNbr[w.vertex] = new WeightedEdgeNode(v, w.weight);
               l.add(0, new EdgeNode(w.vertex));
            }
            else
               // w.vertex is in l
               if (((Comparable) nearNbr[w.vertex].weight)
                     .compareTo(w.weight) &gt; 0)
               {// found a closer neighbor
                  nearNbr[w.vertex].weight = w.weight;
                  nearNbr[w.vertex].vertex = v;
               }
         }
      } 
   }   

   // see if spanning tree was found
   if (i == n - 1)
      return true;
   else
      return false;
}
</pre>
<HR class = coderule>
<br><br>
<dt> (c)
<dd>
First, we analyze the min heap implementation.
The number of min heap insert and remove min operations
is
<code class=var>O(n)</code>
and the number of decrease weight operations is
<code class=var>O(e)</code>.
The total time spent on these operations is
<code class=var>O((n+e) log n)</code>.
The time spent on the rest of the code is
<code class=var>O(n + e)</code> if adjacency lists are used and
<code class=var>O(n<sup>2</sup>)</code> if adjacency
matrices are used.
Since <code class=var>e</code> is
<code class=var>O(n<sup>2</sup>)</code>, the total time is
<code class=var>O(n<sup>2</sup> log n)</code>.
<br><br>
When Fibonacci heaps are used, the time spent on the decrease
key operations is
<code class=var>O(e)</code> and the run time becomes
<code class=var>O(n<sup>2</sup>)</code> when adjacency matrices are used
and
<code class=var>O(n log n + e)</code> when adjacency lists are used.
<br><br>
For the chain implementation, each update of weight takes <code class=code>O(1)</code>
time, each insert into the chain also takes <code class=code>O(1)</code> time,
and selecting the next vertex and edge for the spanning tree takes
<code class=code>O(n)</code> time. So, the complexity is
<code class=code>O(n<sup>2</sup>)</code> regardless of the
graph representation used.
</FONT>
--!>

</BODY>
</HTML>
