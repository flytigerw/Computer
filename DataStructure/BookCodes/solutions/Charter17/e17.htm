<HTML>
<HEAD>
<LINK rel="stylesheet" href="../exer.css">
</HEAD>
<BODY>
<H1>
Data Structures, Algorithms, & Applications in C++<BR>
Chapter 17, Exercise 17<BR>
<BR>
</H1>


<dl compact>
<dt> (a)
<dd>
The profit densities are <code class=var>[0.2, 1.5, 1.5]</code>.  Therefore we
consider the objects
in the order <code class=var>2</code>, <code class=var>3</code>,
<code class=var>1</code>.  Objects <code class=var>2</code> and <code class=var>3</code> are packed and then
<code class=var>0.85</code> of object <code class=var>2</code> is packed.
The solution is <code class=code>x = [0.85, 1, 1]</code> and the profit
earned from the packing is <code class=var>47</code>.

<br><br>
<dt> (b)
<dd>
Consider any instance of the continuous knapsack problem.
We may assume that the objects are given in nonincreasing order of profit
density.  Let <code class=var>x<sub>1</sub> ... x<sub>n</sub></code>
be the greedy solution and let
<code class=var>y<sub>1</sub> ... y<sub>n</sub></code> be an optimal solution.
We shall show that both solutions earn the same profit and so the greedy
solution is also optimal.
<br><br>
Let <code class=var>j</code> be the least integer such that
<code class=var>x<sub>i</sub> = y<sub>i</sub></code>,
<code class=var>1 <= i < j</code> and <code class=var>x<sub>j</sub> != y<sub>j</sub></code>.
If no such <code class=var>j</code> exists, the two solutions are the same and
so the greedy solution is optimal.  Assume such a <code class=var>j</code> exists.
From the way the greedy algorithm works and the fact
that the optimal solution is a feasible solution, we conclude that
<code class=var>x<sub>j</sub> > y<sub>j</sub></code>.
If we increase the fraction of object <code class=var>j</code> in the
optimal solution to <code class=var>x<sub>j</sub></code>
and reduce the fraction of objects <code class=var>j+1, j+2, ...</code>
to compensate for the increased weight used by object <code class=var>j</code>,
the profit cannot decrease because we are replacing lower density
fractions by higher or equal density ones.  This transformation,
therefore, yields a new optimal solution for which
the least integer <code class=var>j</code> such that
<code class=var>x<sub>i</sub> = y<sub>i</sub></code>,
<code class=var>1 <= i < j</code> and <code class=var>x<sub>j</sub> != y<sub>j</sub></code>
(if it exists) is larger than for the old optimal solution.
<br><br>
By applying this transformation a finite number of times,
we convert the original
optimal solution into the greedy solution without decreasing
the profit earned.  So the greedy solution must also be optimal.

<br><br>
<!--
<dt> (c)
<dd>
We shall assume that the profits and weights
are of type <code class=code>double</code>.
First we define a class
<code class=code>Element</code> which is used to sort the objects into
nondecreasing order of profit density.  Following the sort, the objects are
to be packed into the knapsack in the reverse of this order.

<br><br>

The method
<code class=code>gerredyKnapsack</code> packs the objects into the knapsack
in nonincreasing order of profit density.  It returns the profit
generated by the greedy packing.  It also sets <code class=code>x[i]</code>
to be the fraction of object <code class=code>i</code> that is packed
into the knapsack.

<HR class = coderule>
<pre class = code>
public class ContinuousKnapsack
{
   static class Element implements Comparable
   {
      // data members
      int id;   // object identifier
      double d; // profit density

      // constructor
      private Element(int theID, double theDensity)
      {
         id = theID;
         d = theDensity;
      }

     // method of Comparable
     /** return true iff this &lt; x */
     public int compareTo(Object x)
     {
        double xD = ((Element) x).d;
        if (d &lt; xD)
           return -1;
        if (d == xD)
           return 0;
        return 1;
      }
  
      /** return true iff this == x */
      public boolean equals(Object x)
         {return d == ((Element) x).d;}
   }

   /** set x[i] to the fraction of object i included in knapsack,
     * 1 <= i &lt; p.length
     * param p[1:p.length-1] array of profits
     * param w[1:w.length-1] array of weights
     * param c knapsack capacity
     * return value of greedy knapsack filling */
   public static double greedyContinuousKnapsack(double [] p,
                              double [] w, double c, float [] x)
   {
      // define an element array to be sorted by profit density
      Element [] q = new Element [p.length];
      for (int i = 1; i &lt; p.length; i++)
         // array of profit densities
         q[i] = new Element(i, p[i] / w[i]);
   
      // sort by density
      HeapSort.heapSort(q);
   
      // load in nonincreasing order of density and compute profit sum
      double profitSum = 0;      // will be sum of profits
      int i;
      for (i = p.length - 1; i &gt; 0; i--)
      {
         int id = q[i].id;
         if (w[id] <= c )
         {// object id fits
            x[id] = 1;
            c -= w[id];
            profitSum += p[id];
         }
         else
         {// object id is too large
          // take a fraction of this object to fill knapsack
            x[id] = (float) (c / w[id]);
            profitSum += x[id] * p[id];
            break;
         }
      }
   
      // set remaining x[] values to zero
      for (int j = i - 1; j &gt; 0; j--)
         x[q[j].id] = 0;

      return profitSum;
   }
}
<HR class = coderule>
</pre>
<br><br>

The above code together with test data and output appear in the files
<code class=code>ContinuousKnapsack.*</code>.
<br><br>
Since the knapsack will usually get filled after
the first few items have been examined, we can avoid doing a
total sort as is done above.  Instead, we can start by
setting all <code class=code>x[i]</code> to zero and
initializing a max heap with the objects.  Then objects
are extracted from the max heap one by one and packed into the
knapsack until the knapsack is full.  Since a max heap can
be initialized in linear time, the complexity of the new knapsack
algorithm is <code class=var>O(n + k log n)</code>, where
<code class=var>k</code> is the number of objects extracted
from the max heap.
In the worst case, <code class=var>k = n</code> and the complexity
becomes the same as when we started by sorting the objects.
</dl>
--!>

</FONT>
</BODY>
</HTML>
