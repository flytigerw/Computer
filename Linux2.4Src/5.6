
1.文件缓冲:系统会将最近读/写过的文件内容在内存中保留一份副本
           读取文件时，先去缓冲区中查看是否有副本.若有则直接从副本中读取内容，而不必从外设中读取内容.
           写入文件时，先将内容写到副本中.待系统空闲时，再将副本写回设备
  在多进程的系统中，同一文件可能被多个进程共享.文件缓冲的作用则更加显著

  考虑:如何实现缓冲?
       在哪个层次上实现缓冲?
  
  1)每个进程都有自己的用户空间
    若在这一层实现缓冲，那么缓冲的内容不能被其他进程共享.
    而且用户进程需要亲自去管理缓冲区

  2)所有进程都共享内核空间
    内核中的文件系统层包括:
    a.file -- 文件上下文层
      与进程强相关
      不同的进程可以在同一个文件上建立不同的上下文
      单一进程也可以在同一个文件上建立多个不同的上下文
      所以，若在file层设置缓冲区，那么缓冲区贴近特定上下文的使用者，但不利于共享

    b.dentry -- 文件名层
      多个file可共享同一dentry  
      多个dentry也可共享同一inode
      如果在该层设置缓冲区，多个file可共享同一缓冲区
      但同一内容的文件，针对不同的文件名都要设置一个缓冲区.
      要考虑单一缓冲区如何协调多个file的读写请求

    c.inode -- 文件内容索引层
      1.VFS层
        内存inode共有字段,函数表
      2.具体文件系统层
        xx_inode_info
      inode与文件内容是一对一的关系
      Linux2.4就是在该层设置了缓冲区
      该缓冲区为 内存页面链式队列
      以页面而非磁盘块为单位进行缓冲可以将 文件缓冲和文件的内存映射结合在一起 --> 通过修改内存页表就可将缓冲页映射到进程的用户空间中
      缓冲页的读写:
      1.常规写
        read()和write()顺着inode找到目标页面
        若目标页面不存在，就调用设备驱动程序将其读入到内存中
        然后再进行读写
      2.虚存写
        知道页面的虚拟地址范围后，直接读写该地址范围的内容    
        通过MMU将虚拟地址变换为物理地址，若在变换时，发现目标页面不存在，则通过缺页异常将其读入到内存中
    
    d.设备驱动层
      设备驱动的读写单位为磁盘块
      一张内存页面通常对应多个磁盘块 --> 比如内存页面:4K,磁盘块:1K
      从设备驱动的视角来看，以内存页面为单位的缓冲粒度太大,不便于设备驱动操控缓冲区
      即:针对同一内容，不同人的视角不一样
         那么就不能将视角绑定到内容上，要将二者分离
      分离方法:缓冲区中只存放纯内容
               在inode层中添加 "页面视角"   --> page
               在设备驱动层添加"磁盘块视角" --> buffer_head
      在每个视角下，可自定义缓冲区的管理方式. --> 比如在页面视角下，可采用Hash+LRU的方式管理缓冲区中的page

      磁盘块的预读:读取磁盘时，大部分的时间都花在准备工作上，比如寻道，扇区定位
                   相比而言，读写一个磁盘块和读写几个磁盘块的时间都是较少的
                   而且相邻的磁盘块在未来被使用的几率比较大
                   所以一般在读取目标磁盘块时，也会预读相邻的几个磁盘块
      
      由于预读的读取量不限于单个磁盘块，那么file结构中就需要维持两个上下文:
      1.f_reada,f_ramax,f_raend,f_rawin...
        预读上下文
      2.f_pos
        当前正在读写的位置

      当进程发起读取请求时，若目标内容不在内存中，则需要从设备中读入，此时进程就会进入阻塞状态
      那么阻塞多久呢?
      只要目标磁盘块被读入后就可以唤醒进程来处理了，不需要等待至所有的预读块都读入后再解除阻塞
      外设的读取大多采用DMA,不需要CPU太多的干预 --> 磁盘读取和CPU运行(进程运行)可并行执行


2.sys_write(unsigned int fd,const char* buf,size_t count)
  大致流程:
  1)通过fd索引到file*
    并递增file的引用计数:f_count
  2)检查文件是否可写
    file->f_mode & FMODE_WRITE
  3)检查要写入的区间上是否添加了mandatory lock
    locks_verify_area() --> 需要扫描inode结构中的i_flock队列 --> 检查每一个file_lock
  4)不同的文件系统的写操作不一样
    在VFS层:file->f_op->write()
    在ext2文件系统中，f_op对应ext2_file_operatios 或者 ext2_dir_operations
      在文件创建时，根据文件的性质(目录 / 普通文件)来选择相应的函数表进行绑定
      在ext2_file_operatios中，文件的写操作为generic_file_write() --> pdf596

3.generic_file_write()
  文件在磁盘上以磁盘块为存储单位        --->  底层物理结构
  可以对文件进行建模，建立它的逻辑结构  --->  比如可以把文件看做是 以页面为单位组织成 的页面数组
                                              在page中含有字段index,其表示此页面在文件页面数组中的下标
  逻辑结构对上层用户更加友好
  用户在逻辑结构层的操作 被系统转换为 物理结构层的操作

  有了前置背景后，再来看函数大致流程:
  1)如果在file中指定了O_APPEND标志
    则将先定位到文件尾 ->  pos = inode->i_size

  2)检查文件大小是否已经超出限制
    在进程的task_struct中含有数组rlim,其记录了OS对进程所能使用的各种资源大小的限制

  3)其他检查见源码

  4)去掉文件的S_ISUID特权
    remove(inode) --> pdf599

  5)接下来就要对文件内容进行修改
    修改之前先更新inode->ctime,并把inode标记为dirty --> mark_inode_dirty_sync(inode)

  6)写入过程:
    a.循环写入，每次写入前先确定写入位置和写入量
      写入位置:
        在进程眼中,文件为线性字节流,pos为一维坐标,定位到字节流中的某个位置
        在inode眼里,文件为页面数组,所以在inode层进行处理时,需要先将pos变换为二维坐标: (页面下标,页内偏移)

      写入量:
        逐个页面的填充

    b.调用__grab_cache_page()找到目标缓冲页面
      inode层缓冲区为全局性的:采用Hash+LRU管理所有的文件缓冲页面
      每个inode通过字段address_space* i_mapping字段与全局缓冲区对接
      缓冲页面的hash值:hashfn(i_mapping地址+页面下标)
      如果没找到就调用page_cache_alloc(mapping)分配新的空页面，并将其纳入到hash表中
      对于新分配的空白缓冲页面，则需要建立设备驱动层需要的"磁盘块"视角 --> buffer_head --> 在page中含有字段buffer_head* buffers --> 该页面对应哪些磁盘块
      再将页面内容从设备中读入
   
    c.在写入前还需要做一些准备工作
      在VFS层为:i_mapping->a_op->prepare_write()
      在ext2文件系统中，其为:ext2_prepare_write() --> pdf603
      大概流程:
      1.若目标缓冲页面为空页面，则为其建立"缓冲块"视角 --> create_empty_buffers()
        建立大致过程:比如一个页面大小 = 四个缓冲块大小
                     那么就需要创建4个buffer_head结构
                     每个buffer_head中都记录了页面中缓冲块的基址
                     并将buffer_head链入page的buffers队列中   --->  详见ppt和源码

      2.内外内容一致性的考虑
        若一个缓冲页面上的内容是一致的(与外存的内容保持一致)，那么页面中的所有缓冲块的内容也都保持一致
        但若缓冲页面上的内容不一致，则未必每个缓冲块的内容都不一致
        所以需要遍历缓冲页面上的缓冲块，若发现其内容不一致，就调用驱动程序ll_rw_block()将内容从外设读取到缓冲区中
        在page和buffer_head中都有标志位:xxUpdate --> 提供一致性检测

        若缓冲页面是新分配的空页面，则需要先从外设中读取内容到页面中
        并建立缓冲块和磁盘块的映射  --> 映射存储在buffer_head中 --> 即该缓冲块对应哪个磁盘上的哪一个磁盘块
        在VFS层:读取函数为:get_block()
        在ext2文件系统中:其为:ext2_get_block(inode,iblock,bh,create)
         iblock为要读取的缓冲块的逻辑块号 --> 可由页面下标和页内偏移推导出
         读取大致流程:
         1)将逻辑块号变换为磁盘块号
           可以用数组建立二者的映射关系:以逻辑块号为下标，磁盘块号为数组元素
           假如文件大小为2G,缓冲块大小为1KB,那么数组大小为:2^21  ---> 数组太大，肯定不能全部存储在内存中
           上述映射为1级映射 --> 源元素通过一次映射就可以变换得到目标元素
            好处:快  
            缺点:由于源元素和目标元素之间只有一个映射层
                 如果不做其他处理，就需要将整个映射层都存储在内存中   
                  当然，若源元素可通过逻辑变换得到目标元素，就不需要空间来存储二者的映射

           改进:将目标映射层进行分段，每一段都存储在某个外存单元中
                在内存只需记录 源元素和目标映射段之间的映射: 源元素接口-目标映射段接口(外存单元地址)
                
           源元素变换到目标元素的过程:
           a.源元素 -> 目标映射段(外存单元)
           b.读取外存单元到内存中，得到目标映射段
           c.源元素+目标映射段 -> 目标元素
           改进的映射过程就为二级映射
            好处:将占空间的目标映射层分段存储在外存中
                 在内存中建立中间映射层，实现一个目标元素到一个目标映射段的 映射
                 以减少内存消耗
            缺点:慢
           
           Unix文件系统结合了一级和多级映射
           在ext2_inode_info含有字段i_data[15]
           若磁盘块大小为1KB
           前12个元素用于缓冲块号的一级映射: 缓冲块号-目标磁盘块号
                                             若文件大小小于12KB,就可以采用一级映射快速找到目标磁盘块
                                             
           第13个元素用于缓冲块号的二级映射: 缓冲块号-外存单元号(磁盘块号)
                                             在该外存单元中存储着一级映射段:在此情景中就为整型数组
                                                                            每个元素都表示一个目标磁盘块号
                                             设整型元素大小为4byte，那么一个外存单元存储的一级映射段的大小为:256
                                             一个二级映射的映射范围大小:256
                                             当前二级映射对应的文件大小范围:12KB~268KB

           第14个元素用于缓冲块号的三级映射: 缓冲块号-外存单元号(磁盘块号)
                                             在该外存单元中存储着二级映射段:在此情景中就为整形数组
                                                                            每个元素都表示一个磁盘块号 -> 每个磁盘块中都存储着一级映射段
                                             一个外存单元存储的二级映射段的大小为:256
                                             由于一个二级映射的映射范围大小为256
                                             所以一个三级映射的映射范围大小为:256*256 -> 64K
                                             当前三级映射对应的文件大小范围:268KB~64M

           第15个元素用于缓冲块号的四级映射: 缓冲块号-外存单元号(磁盘块号)
                                             在该外存单元中存储着三级映射段:在此情景中就为整形数组
                                                                            每个元素都表示一个磁盘块号 -> 每个磁盘块中都存储着一级映射段
                                             一个外存单元存储的三级映射段的大小为:256
                                             由于一个三级映射的映射范围大小为256*256
                                             所以一个四级映射的映射范围大小为:256*256*256 -> 16M
                                             当前三级映射对应的文件大小范围:64M~16G
           
           具体变换和读入过程见pdf612+ppt
         
         2)路径查找结果分析
           a.找到了目标磁盘块，将其读入到内存形成缓冲块
             再释放沿途的中间缓冲块
           b.路径断裂，不能通向最终目标磁盘块号
             比如磁盘块号为900，则其位于第三级映射范围中.其在各个层次的偏移量为:13,2,120
             映射是根据需要动态建立的
             所以可能当前i_data[13]并没有与一个磁盘块建立映射，更别谈后续的映射情况
              在此情况下，需要先分配一个磁盘块b1，读入到内存中生成缓存块，然后让其与i_data[13]建立映射
                          在分配一个磁盘块b2,让其与b1[2]建立映射 --> 需要修改磁盘块b1的内容
                          由于目标磁盘块对应的缓冲块已经存在于缓冲页面中，所以不需要再额外分配目标磁盘块.直接让其与b2[120]建立映射
             代码见pdf618

           如何分配新的磁盘块呢?
           a.磁盘块号的分配
             我们希望文件所有的磁盘块尽量在设备上连续
             在ext2_inode_info中含有两个字段:
              a.i_next_alloc_block : 下次要分配的逻辑块号
              b.i_next_alloc_goal  : 下次期望分配的磁盘块号
             正常情况下，二者平行向前推进
             文件的逻辑块号可能不连续 --> 文件的扩充是跳跃性的 --> 含有文件空洞 --> lseek()将读写位置推到了文件末尾之后
             在这种情况下就调用ext2_find_near()来设置i_next_alloc_goal

             i_next_alloc_goal只是一个建议值.但有可能其对应的磁盘块已经被占用
             所以会调用ext2_allo_block()根据建议值寻找实际可用的磁盘块号
             寻找策略:pdf 621

             找到后，就可以与前一个路标建立映射.比如:b1[2]= Block of b2


           b.有了设备号+磁盘块号后，就可将磁盘块读入.
             目标磁盘块读入内存后，可放到缓冲页面中缓冲块中
             那么这些中间磁盘块读入内存后放到哪呢?
             可以在内存中开辟缓冲区来容纳读入的磁盘块

             缓冲区缓冲块组成.缓冲区是缓冲块的逻辑容器
             缓冲块存放纯内容.用buffer_head描述其特征信息(比如缓冲块地址)
             buffer_head就是其他用户观察缓冲块的视角
             通过直接管理buffer_head就可达到间接管理缓冲块的效果
             Linux2.4采取的管理策略:Hash(快速查找)+LRU(淘汰策略)+FreeListSize(快速得到指定大小的空闲缓冲区)

             所以先调用getblk(dev,nr,size)，在缓冲区中为该磁盘块分配合适的缓冲块
             程序流程:
              1.查找Hash表，看是否有之前的缓冲块还存在于缓冲区中
              2.若有，则返回之
              3.若没有，则从自由链表中摘取一个指定大小的缓冲块
                若摘到了，则对buffer_head进行初始化.重点关注b_dev和b_blocknr --> 该缓冲块与哪一个磁盘块相关联
                          然后将其从插入到LRU队列队首
              4.若没摘到，则先对缓冲区进行扩张 --> 分配额外的内存页面来填充缓冲区 --> 先分配内存页面，再分割插入到自由链表中
              5.若扩张失败，则调用free_more_memory()"淘汰"一些缓冲块
                唤醒内核线程bdflush() --> 根据LRU策略将一些将脏的缓冲块写回到设备中
        
    d.准备好以后，就将内容从用户空间拷贝到目标缓冲区中
      设置缓冲区的update标志(commited),然后涉及到的缓冲页面交给kflushd --> 内核线程，动态性地将缓冲页面写回设备中
      


4.类似sys_write(),sys_read()的主体为generic_file_read(file* file,char* buf,size_t count,loff_t* pos) --> pdf634
  1)简单检查:比如是否为目录，buf的大小等等

  2)调用do_generic_file_read()  --> pdf635
    a.设置当前最大预读量
      在内核中记录了每个设备支持的最大预读量
      int* max_readahead[MAX_BLKDEV] --> 二维数组.用(主设备号,次设备号)进行索引

      在file中含有f_raend,f_rawin等字段,其以窗口的形式来表示 预读的内容
      f_raend为窗口末,f_rawin为窗口大小
      当前的读写位置:file->f_pos  --> 线性字节流视角 --> 转为页面数组视角(index,offset)
      若读写位置位于预读窗口外,则稍后读取内容时,必须从磁盘读
      若位于窗口内,则稍后读取内容时,可先从 预读块中读取部分内容(最大读取量:预读窗口末-当前读写位置 -->记录到f_ramax)
                                    若不够,则再从磁盘中读取
    
    b.正式地读取也是一个循环 --> 逐个页面的读出
      1.先确定 读取位置+写入量

      2.在缓冲区中寻找缓冲页面 --> 页面的hash值: hashfn(inode->i_mapping,pageIndex)
        有三种查找情况:
        1)找到了,且缓冲页面的内容与外存内容保持一致(该缓冲页面已经提交给内核线程kflushd)
          page_ok:
           调用file_read_actor()将缓冲页面的内容复制到用户空间缓冲区中，并推进读写位置

        2)找到了，但并没有保持一致
          page_not_up_to_date:
           通常页面不一致是因为有人正在向该页面写入内容，且还没有提交，需要等待其写入完成
           既然要等待，不妨趁机预读一些页面:调用generic_file_readahead()启动预读 --> 启动预读而非完成预读

           启动预读后，再次检查其是否达到一致性
           若已经一致，则跳转到page_ok
           否则要考虑从外设中读取内容到缓冲页面中.
           lock_page(page) ---> 保证缓冲页面操作的互斥性
           隐含着等待，若有进程正在写入缓冲页面，那么会等待至写入完成后才能获得锁
           所以加锁成功后，继续检查页面一致性
           若已经一致，则unlock_page,再goto page_ok
           否则进入到readpage处，从外设中读取内容到缓冲页面中  --> 为什么会出现这种情况?????

        3)没找到缓冲页面
          新分配一个内存页面,加入到缓存中:Hash表,LRU队列,i_mapping中
          细节考虑:内存页面的分配并不是一蹴而就的,进程可能进入睡眠等待中
                   睡眠时,可能有其他进程已经抢先为目标页面建立了缓冲
                   所以醒来后，应先查看是否已经存在与缓存中
                   若存在，则goto found_page.对于新分配的内存页面，则不着急释放，在后续的读取过程可能会用到

          然后goto readpage

readpage:
 1)VFS层调用:inode->i_mapping->a_ops->readpage(file,page)
   在ext2文件系统中为:ext2_read_page(file,page)
                      其调用 block_read_full_page(page,ext2_get_block) --> 相对通用的函数
                                                       完成缓冲块到磁盘块的映射

   block_read_full_page(page,get_block) --> pdf642
    a.读取时要保证缓冲页面已加锁
  
    b.若缓冲页面没有"磁盘块视角"，则建立之
      create_empty_buffers()
  
    c.缓冲页面不一致可能是因为某个缓冲块不一致
      所以需要逐个检查缓冲块
      1.若缓冲块没有与磁盘块建立映射，则调用get_block(inode,iblock,bh,0) 
        get_block:会将逻辑块号变换为对应的磁盘块号.然后磁盘块的内容读取到缓冲块中
                  参数0表示若对应的磁盘块号不存在，则不会为其分配新的磁盘块
                  在写入文件时，也会调用该函数，但参数为1

        若在调用了ext_get_block()后，缓冲块仍然没有物理块建立映射
        表明该文件逻辑块没有与之对应的物理磁盘块 --> 正在读取文件空洞  --> 读取的内容为0

      2.缓冲块已经和磁盘块建立映射，但二者内容不一致
        先将这些缓冲块收集起来，循环结束后，再逐个同步 
          将磁盘块的内容读入到缓冲块中
          磁盘的读取为DMA --> 不需要CPU过多的参与 
          CPU和磁盘读取可并行 --> 从block_read_full_page()返回时，磁盘块也许还没有读取到缓冲块中 --> 缓冲页面尚未一致
                读取完毕后，end_buffer_io_async()会做收尾处理:SetPageUpdate(page),UnlockPage(page)
              
         

 2)检测缓冲页面的一致性
   若一致，则goto page_ok
   否则要等待至磁盘块读入到缓冲块中. 等待前先开启预读generic_file_readahead()
     wait_on_page(page)--> 若page已加锁，就将当前进程添加到page的等待队列中，再schedule() 
                           等待至page解锁时被唤醒  --> 在end_buffer_io_async()中会解锁
                           醒来后再次检测page是否被其他 醒来者抢先加锁(不适用于当前情景).若有,则再次睡眠等待.
                           最后将当前进程移出page的等待队列中,然后返回

   醒来后，再次检测缓冲页面的一致性 --> 正常情况下，应该是一致的，否则就是ERROR

  
  
