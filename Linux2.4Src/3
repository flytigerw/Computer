
1.中断有三种
  1)CPU在执行程序时，由内部产生
    比如在程序中使用 "INT n" 指令，让CPU主动进入中断状态
    此类中断也称为 陷阱Trap

  2)CPU外部产生 --> 外部中断
    中断的发生无法预测,比如IO中断
    CPU对于中断的响应是被动的
    内核可以通过"关中断"指令来关闭对中断的响应(除了不可屏蔽中断)

  3)异常:比如除数为0，缺页异常


2.CPU对于陷阱，外部中断，异常的响应机制是类似的:
  外部中断源提供中断向量，陷阱的向量由指令指出(INT n)，异常向量则预先设置于CPU的硬件结构中
  CPU根据向量号，去查表找到相应的服务程序，并调用之

3.Intel x86的中断表支持256种中断向量表
  中断表表项称为门,分为4种
  1)任务门
    重要字段:16位的TSS段选择码
    TSS:Task State Segment
    是用于保存 进程运行现场 的数据结构，存放在GDT表中
    其包括CPU中所有与进程有关的寄存器内容(比如CR3)以及三个堆栈指针

    中断发生时，若CPU根据向量号在中断表中找到的表项为任务门
    那么CPU会将当前进程的运行现场保存在相应的TSS中
    并将任务门指向的TSS的内容装入到CPU中的各个寄存器中
    从而完成一次进程的切换

    在CPU中设有寄存器TR --> 指向当前任务的TSS

    Linux内核并不采用任务门作为进程切换的手段
    进程切换时的寄存器副本保存在进程的系统栈中，而不是TSS中
    Linux内核会遵循硬件的要求，将TR寄存器指向一个TSS
    进行栈切换时，就从TSS中拿出系统栈指针(SS0和ESP0)
    所以进程切换时，也就只需要更改TSS中保存的进程的系统栈
    
 
  2)中断门，陷阱门，调用门  ---> pdf 204
    三者在结构上类似

    中断门和陷阱门的区别:
     通过中断门进入中断服务程序时，CPU会关中断，以防止嵌套中断的发生--> 将EFLAGS寄存器中的IF标志位清0
     通过陷阱门进入中断服务程序时，CPU会维持IF标志位不变

    与任务门的异同点:
      门中的段选择码都用于索引GDT中的表项 (Linux内核基本不使用LDT)
      对于中断门，陷阱门，调用门，其索引的段表项为 代码段描述项
      而对于任务门，其索引的段表项为 TSS描述项


4.在Linux内核中，其基本不使用任务门和调用门
  所以其只需要使用部分 i386CPU提供的 特权级的检查机制  --->  显得不那么复杂
  比如:
   当用INT n进入中断服务程序时
   CPU先用向量号n索引中断表，得到一扇门(中断表表项)
   在此情景下，其为陷阱门
   然后将 门的DPL 与 CPU的CPL 相比，必须要CPL <= DPL，才能穿过这扇门  --> 必须要高特权才能穿过门
   若中断是由外部中断(比如IO中断)或者CPU内部异常(比如缺页异常)产生，则不需要进行这一层的检验

   通过门的段选择码可以索引到GDT中的某个表项 --> 在此情景下为 代码段描述项
   
   然后将 代码段描述项中的DPL 与 CPU的CPL相比，必须要DPL <= CPL才能继续向前
   这两个环节中的任何一个失败都会导致general protection exception

   进入中断服务程序的步骤:
   1)CPU将当前EFLAGS寄存器 + 返回地址 压入堆栈中
     EFLAGS:反映了CPU的状态
     返回地址:中断结束后，要返回到用户进程的某条指令继续执行
              指令地址:CS代码段寄存器 + EIP指令指针(段内偏移)
   2)如果中断是由异常引起的
     则也要将表示异常原因的出错码也压入栈中
   3)如果目标代码段描述项中的DPL与CPL不同，那么就要更换栈 --> 比如中断发生在用户态，进入内核后，要切换为内核栈
                                                                若中断发生在内核态(比如缺页异常)，则不用切换
     先保存用户栈:压入SS和ESP
     进程的内核栈位于进程的TSS中 --> 所以根据TR找到当前进程的TSS，将其中的内核栈装入到SS和ESP中

  pdf 207

5.中断向量表:IDT
  基址由寄存器IDTR指示
  Linux内核在完成对页式虚存管理的初始化以后，便调用trap_init()和init_IRQ()进行IDT的初始化 --> pdf208

  IDT的中断门的DPL设置为0
  当中断是由外部或者CPU异常产生时，中断门的DPL与CPU的CPL检查会被忽略             ---> 总能穿过中断门
  当用户进程想要通过INT n访问某个中断门时，由于用户进程的CPL为3，大于中断门的DPL ---> 不能穿过中断门
                         访问某个陷阱门时，比如INT 0x80，由于陷阱门的DPL为3      ---> 可以穿过陷阱门

  对于外设的中断门
  由于外设种类较多
  所以可能多个外部设备共用一个中断向量号
  Linux为每个中断向量号向设置一个队列,外设初始化时,会将自己的中断服务程序挂到对应的向量号的队列上
  当中断发生时，首先执行与中断向量相对应的一段总服务程序
                然后再根据中断源的设备号在 中断向量号的队列中 找到对应的服务程序并执行之
              

6.一次外设中断流程模拟:
  1)外设产生一次中断请求
    该请求通过中断控制器8259A到达CPU的中断请求引线INTR
    CPU在执行完当前指令后就响应此次中断请求

  2)CPU从中断控制器中取得中断向量
    然后根据向量号在IDT表索引具体的表项
    在此情景下，其是中断门

  3)此次中断是当CPU在用户空间中运行时发生的 --> CPL=3 而 DPL=0
    外设中断不会进行第一次特权级检查,穿过中断门后就关中断
    CPL与DPL不同，需要切换到内核栈
    
  4)中断服务程序的总入口: pdf 221
    关键操作:
     a.保存现场  pdf222
     b.通过向量号索引到对应的 中断请求队列
     c.依次执行队列中的中断服务程序 --> 其可以读取外设的中断终态寄存器，看是否有来自该设备的中断请求
                                        若有，则继续服务
  
  5)在Linux中，外设的中断服务有两个阶段
    比如敲击键盘
    第一阶段:通过中断读取被敲击的字符 --> 中断要立即响应,会关中断
    第二阶段:判断字符是什么           --> 后续的操作比较费时，需要开中断  --> bottom half
                                          
  6)中断返回前，会先处理该进程中待处理的信号
  7)中断返回,恢复现场(pop之前压入的寄存器),从内核栈切换到用户栈,继续执行用户进程指令


7.时钟中断
  系统时钟涉及到内核中的两个全局量:
  1)struct timeval{
     time_t        tv_sec;
     suseconds_t   tv_usec;
    }xtime;
    其记录从历史上某一时刻开始的时间的绝对值
    数值来自CMOS晶片 --> 由单独的电池供电
    通过get_cmos_time()从CMOS晶片读取时间到xtime  -->  精度为秒

  2)unsigned long jiffies
    其记录开机以来时钟中断的次数

  高精度时钟实现:在i386的CPU中，设置了特殊的64位寄存器TSC
                 其对 驱动CPU的时钟脉冲 进行计数         ---> 参考libgo的FastSteadyClock

  时钟中断服务程序为timer_interrupt() ---> pdf251


8.系统调用
  例子:
  函数原型: int sethostname(const char* name,size_t len);
  内部定义: _syscall2(int,sethostname,const char*,name,size_t,len)
  宏定义为: #define _syscall2(type,name,type1,arg1,type2,arg2) \
                    type name(type1 arg1,type2 arg2)\
                    {\
                      long res;
                      __asm__ volatile("int $0x80" \
                                        :"=a"(res) \
                                        :"0"(__NR_##name),"b"((long)(arg1)),"c"((long)(arg2)\
                                      );\
                      __syscall_return(type,res);\
                    }
            #define __syscall_return(type,res) \
                    do{ \
                      if((unsigned long)(res) >= (unsigned long)(125)){ \
                        errno = -(res);\
                        res = -1;\
                      }\
                      return (type)(res); \
                    }while(0)     
  
  展开为:int sethostname(const char* name,size_t len){
                    long res;
                    __asm__ volatile("int $0x80"  
                                      :"=a"(res)                //输出部
                                      :"0"(__NR_sethostname),"b"((long)(name)),"c"((long)(len)  //输入部
                                    );
                    do{
                      if((unsigned long)(res) >= (unsigned long)(125)){
                        errno = -res;
                        res = -1;
                      }
                      return (long)(res);
                    }while(0)
         }
  易知:
  汇编语句:int $0x80
  输入部  :__NR_sethostname(常量0x4a)绑定到%eax中
           name绑定到%ebx,len绑定到%ecx
  输出部  :返回值存在%eax，其与res绑定
        
  生成的汇编为:
    mov  %ebx,%edx              //后面要用到ebx,所以先保存

    mov  0x8(%esp,1),%ecx       //进入函数sethostname()时，esp指向返回地址 -> esp+4就为第一参数，esp+8就为第二参数
    mov  0x4(%esp,1),%ebx
    mov  $0x4a,%eax             //将系统调用号交给eax
    int  $0x80                  //通过中断进入内核
    mov  %edx,%ebx
    cmp  $0xfffff001,%eax       
    jae  1a <sethostname+0x1a>  //重定位信息，在链接时会把地址__system_error()填入到此处
    ret
  系统调用时通过寄存器而是栈传递参数的原因 ---> 从用户空间进入内核空间时，会进行栈切换

  int $0x80进入内核过程:
  1)在IDT表中索引下标为80的表项 --> 为陷阱门，DPL=3
    CPL=3 <= DPL=3  --> 可以穿过陷阱门
    穿过陷阱门时不会关中断  -->   系统调用可打断
  2)通过陷阱门的段选择码，在GDT表中索引，得到目标代码段描述项，DPL=0
    CPL=3 >= DPL=0  --> 验证通过
  3)段描述符项中的函数指针指向system_call()
    跳转执行system_call()之前，会先切换内核栈 

  system_call()大致思想:所有的服务程序的函数指针存放在sys_call_table中
                        根据系统调用号去索引相关的服务程序，然后调用之

           


